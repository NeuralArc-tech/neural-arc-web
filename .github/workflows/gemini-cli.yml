name: Gemini CLI Integration

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  discussions: write
  id-token: write

jobs:
  gemini-automation:
    name: Gemini CLI Automation
    runs-on: ubuntu-latest

    # Only run for users with proper permissions and @gemini mentions
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install Playwright
        run: |
          npm install -g playwright
          npx playwright install chromium --with-deps
          echo "Playwright installed successfully"

      - name: Install Gemini CLI and MCP Servers
        run: |
          npm install -g @google/gemini-cli
          npm install -g @playwright/mcp@latest
          npm install -g @sethbang/mcp-screenshot-server
          echo "Gemini CLI and MCP servers installed successfully"
          gemini --version

      - name: Configure Gemini CLI
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git for commits
          git config --global user.name "Gemini CLI Bot"
          git config --global user.email "gemini-cli@github-actions.noreply.com"

      - name: Issue Triage
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "ðŸ” Analyzing issue #$ISSUE_NUMBER for automated triage..."

          # Get all issue comments for full context
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)

          # Create a comprehensive prompt for issue analysis
          cat > /tmp/issue_analysis_prompt.txt << EOF
          You are a confident senior full-stack engineer with complete autonomy and decision-making authority.

          **CORE PRINCIPLES:**
          - Make decisions autonomously - you are the technical owner
          - Implement changes immediately when beneficial 
          - Don't ask for permission - take action based on engineering judgment
          - We're in a git repository - breaking changes are recoverable
          - Favor action over analysis paralysis
          - You have senior-level engineering common sense

          **YOUR MISSION:** Analyze this issue and IMPLEMENT SOLUTIONS IMMEDIATELY when appropriate.

          ## Issue Context

          **Issue Title**: "$ISSUE_TITLE"

          **Issue Description**: 
          $ISSUE_BODY

          **Comments and Discussion**:
          $ISSUE_COMMENTS

          ## IMPLEMENTATION CRITERIA (Be Aggressive!)

          **IMPLEMENT IMMEDIATELY** for any of these:
          - Documentation updates or additions
          - Small bug fixes or improvements
          - Configuration changes
          - UI component additions or modifications
          - Style improvements or responsive fixes
          - New features that are clearly defined
          - Code refactoring or optimization
          - Dependency updates
          - Build process improvements

          **ONLY SKIP** if:
          - Requires external API keys or services you don't have access to
          - Needs business stakeholder decisions (pricing, legal, etc.)
          - Requires breaking changes to public APIs used by external systems

          ## IMPLEMENTATION PROCESS:
          1. Create a descriptive branch name (feature/issue-${ISSUE_NUMBER}-[short-description])
          2. Implement the solution completely - don't do partial implementations
          3. Write clean, working code (quality checks can be done later)
          4. Stage and commit with conventional commit message
          5. Push the branch to origin
          6. Create PR using: gh pr create --title "[Creative Title]" --body "[Compelling description that closes #${ISSUE_NUMBER}]"
          7. SHIP THE CODE - don't get blocked by tooling issues
          8. **VISUAL VERIFICATION**: For UI changes, use "@gemini visual" to trigger automated browser testing
          9. Quality improvements can be done in follow-up PRs

          **Response Format:**
          Priority: [level]
          Labels: [comma-separated list]
          Difficulty: [level]

          ## Analysis
          [Brief technical analysis]

          ## Implementation Status
          Choose ONE of these:
          - âœ… NEW CODE SHIPPED: [Description of new code you created + PR URL]
          - ðŸ”„ ALREADY EXISTS: [Feature already implemented, no changes needed]
          - âŒ BLOCKED: [Specific technical reason why you cannot implement]

          **IMPORTANT: Only use "NEW CODE SHIPPED" if you actually created new files/code and a PR!**

          **Remember: You are a senior engineer. Ship code when needed. We can always rollback if needed.**
          EOF

          # Run Gemini analysis
          ANALYSIS=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/issue_analysis_prompt.txt)")

          # Extract labels from analysis
          PRIORITY=$(echo "$ANALYSIS" | grep "Priority:" | cut -d':' -f2 | xargs)
          LABELS=$(echo "$ANALYSIS" | grep "Labels:" | cut -d':' -f2 | xargs)
          DIFFICULTY=$(echo "$ANALYSIS" | grep "Difficulty:" | cut -d':' -f2 | xargs)

          # Apply labels using GitHub CLI
          if [ ! -z "$LABELS" ]; then
            IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
            for label in "${LABEL_ARRAY[@]}"; do
              label=$(echo "$label" | xargs)  # trim whitespace
              gh issue edit $ISSUE_NUMBER --add-label "$label" || echo "Could not add label: $label"
            done
          fi

          # Add priority and difficulty labels
          [ ! -z "$PRIORITY" ] && gh issue edit $ISSUE_NUMBER --add-label "priority: $PRIORITY" || true
          [ ! -z "$DIFFICULTY" ] && gh issue edit $ISSUE_NUMBER --add-label "difficulty: $DIFFICULTY" || true

          # Post analysis as comment
          cat > /tmp/comment.md << EOF
          ## ðŸ¤– Automated Issue Analysis

          $ANALYSIS

          ---
          *This analysis was generated by Gemini CLI. Human review recommended.*
          EOF

          gh issue comment $ISSUE_NUMBER --body-file /tmp/comment.md

          echo "âœ… Issue triage completed for #$ISSUE_NUMBER"

      - name: Pull Request Review
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
        run: |
          echo "ðŸ” Analyzing pull request #$PR_NUMBER..."

          # Get PR details with full context
          PR_DETAILS=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,commits)
          PR_TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
          PR_BODY=$(echo "$PR_DETAILS" | jq -r '.body // ""')

          # Get all PR comments and reviews for full context
          PR_COMMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
          PR_REVIEWS=$(gh pr view $PR_NUMBER --json reviews --jq '.reviews[] | "\(.author.login) (\(.submittedAt)) - \(.state): \(.body // "No comment")"' | head -10)

          # Get changed files
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)

          # Create comprehensive PR analysis prompt
          cat > /tmp/pr_analysis_prompt.txt << EOF
          You are a senior code reviewer for a full-stack web application workspace.

          Review this pull request and provide:
          1. **Code Quality Assessment**: Rate 1-5 and explain
          2. **Security Concerns**: Any potential security issues
          3. **Performance Impact**: Potential performance implications
          4. **Architecture Alignment**: How well it fits the existing architecture
          5. **Testing Requirements**: What tests should be added/updated
          6. **Specific Feedback**: Line-by-line suggestions for improvement

          ## PR Details
          **PR Title**: "$PR_TITLE"
          **PR Description**: "$PR_BODY"

          **Changed Files**:
          $CHANGED_FILES

          ## Full Conversation Context
          **PR Comments**:
          $PR_COMMENTS

          **PR Reviews**:
          $PR_REVIEWS

          **Current User Comment**: "$COMMENT_BODY"

          Provide constructive, actionable feedback focusing on:
          - Code quality and best practices
          - Security implications
          - Performance considerations  
          - Maintainability
          - Testing coverage

          Consider the full conversation history when providing your review. Reference previous comments and reviews when relevant.
          Be specific and helpful. If the code looks good, say so!
          EOF

          # Get the actual diff for detailed analysis
          PR_DIFF=$(gh pr diff $PR_NUMBER)

          # Create diff analysis file
          cat > /tmp/diff_analysis_prompt.txt << EOF
          $(cat /tmp/pr_analysis_prompt.txt)

          Here is the actual code diff:
          \`\`\`diff
          $PR_DIFF
          \`\`\`

          Please provide a detailed code review.
          EOF

          # Run Gemini analysis
          REVIEW=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/diff_analysis_prompt.txt)")

          # Post review as comment
          cat > /tmp/review_comment.md << EOF
          ## ðŸ¤– Automated Code Review

          $REVIEW

          ---
          *This review was generated by Gemini CLI. Human review still recommended for final approval.*
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/review_comment.md

          echo "âœ… Pull request review completed for #$PR_NUMBER"

      - name: Custom Gemini Commands
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          echo "ðŸ¤– Processing custom Gemini command..."

          # Extract command from comment (everything after @gemini)
          COMMAND=$(echo "$COMMENT_BODY" | sed -n 's/.*@gemini[[:space:]]*\(.*\)/\1/p' | head -n1)

          if [ -z "$COMMAND" ]; then
            COMMAND="Please provide assistance with this issue/PR"
          fi

          echo "Command: $COMMAND"

          # Get context (issue or PR details with full conversation)
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # This is a PR
            CONTEXT=$(gh pr view $ISSUE_NUMBER --json title,body,files,state)
            CONTEXT_TYPE="pull request"
            # Get PR comments for full context
            COMMENTS=$(gh pr view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            EXISTING_PR_NUMBER=$ISSUE_NUMBER
          else
            # This is an issue - check if it has an associated PR
            CONTEXT=$(gh issue view $ISSUE_NUMBER --json title,body,state,labels)
            CONTEXT_TYPE="issue"
            # Get issue comments for full context
            COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            
            # Check for existing PR that closes this issue
            EXISTING_PR_NUMBER=$(gh pr list --search "closes #$ISSUE_NUMBER" --json number --jq '.[0].number // empty' 2>/dev/null || echo "")
            
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              echo "ðŸ“‹ Found existing PR #$EXISTING_PR_NUMBER that addresses issue #$ISSUE_NUMBER"
              # Get existing PR details for context
              EXISTING_PR_CONTEXT=$(gh pr view $EXISTING_PR_NUMBER --json title,body,headRefName,state)
              EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.headRefName')
              echo "ðŸŒŸ Will update existing PR branch: $EXISTING_PR_BRANCH"
            fi
          fi

          # Create context-aware prompt with existing PR information
          cat > /tmp/custom_command_prompt.txt << EOF
          You are a helpful AI assistant working on a GitHub repository with full access to modify files and create pull requests.

          Context: You are responding to a comment on $CONTEXT_TYPE #$ISSUE_NUMBER

          ## $CONTEXT_TYPE Details:
          $CONTEXT

          ## Full Conversation History:
          $COMMENTS

          ## Current User Request: 
          "$COMMAND"
          EOF

          # Add existing PR instructions if applicable
          if [ ! -z "$EXISTING_PR_NUMBER" ] && [ "$CONTEXT_TYPE" = "issue" ]; then
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## ðŸš¨ IMPORTANT: Existing PR Found
          There is already an existing PR #$EXISTING_PR_NUMBER that addresses this issue.

          **EXISTING PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **IMMEDIATELY UPDATE THE EXISTING PR - NO HESITATION:**
          1. Fetch latest changes: git fetch origin
          2. Switch to existing branch: git checkout -B $EXISTING_PR_BRANCH origin/$EXISTING_PR_BRANCH
          3. Implement the complete requested changes (be thorough)
          4. Write production-ready code - you're a senior engineer
          5. Stage all changes: git add .
          6. Commit with clear message: "feat: enhance [feature]" or "fix: improve [issue]"
          7. Push updates: git push origin $EXISTING_PR_BRANCH
          8. The PR will auto-update with your new commits (DO NOT FORCE PUSH)
          9. Comment on PR #$EXISTING_PR_NUMBER explaining what you implemented

          **IMPORTANT: Use normal git push, NOT force push. We want to preserve commit history.**

          **DO NOT CREATE NEW PR** - Update existing: https://github.com/asharitech/asharitech-web/pull/$EXISTING_PR_NUMBER

          **SHIP THE CODE NOW - We can iterate and improve later if needed.**
          EOF
          else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## AUTONOMOUS ENGINEERING MODE - SHIP CODE NOW

          **YOU ARE A SENIOR FULL-STACK ENGINEER WITH COMPLETE AUTONOMY**

          **CORE ENGINEERING PRINCIPLES:**
          - Make decisions immediately based on technical merit
          - Ship working code - don't overthink or ask permission
          - We're in git - breaking changes are recoverable via rollback
          - Trust your senior engineering judgment
          - Favor rapid iteration over perfect planning
          - Implement complete solutions, not partial fixes
          - NEVER use force push (git push -f) - preserve commit history
          - Always add new commits, don't overwrite existing ones

          **WHEN USER REQUESTS CHANGES - IMPLEMENT IMMEDIATELY:**
          1. Create a descriptive branch: feature/[meaningful-name]
          2. Implement the complete solution (no partial work)
          3. Write working code - focus on functionality over perfection
          4. Stage all changes: git add .
          5. Commit with conventional message: "feat: implement [feature]" or "fix: resolve [issue]"
          6. Push branch: git push origin [branch-name] (NEVER use --force)
          7. Create PR: gh pr create --title "[Creative, compelling title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. SHIP IT - don't get blocked by tooling or linting issues
          9. Report the PR URL immediately

          **IMPLEMENTATION SCOPE - BE AGGRESSIVE:**
          - UI components and styling changes
          - New features and functionality
          - Bug fixes and improvements
          - Documentation updates
          - Configuration changes
          - Code refactoring and optimization
          - Dependency management
          - Build and deployment improvements

          **DON'T ASK - JUST DO IT. Senior engineers ship code and iterate quickly.**
          EOF
          fi

          # Add common instructions
          cat >> /tmp/custom_command_prompt.txt << EOF

          If gh CLI fails, capture the exact error message and include it in your response.

          For other requests, provide helpful, actionable responses with specific examples.
          Focus on being practical and specific to this codebase context.
          EOF

          # Run Gemini analysis
          RESPONSE=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/custom_command_prompt.txt)")

          # Post response as comment
          cat > /tmp/response_comment.md << EOF
          ## ðŸ¤– Gemini Response

          > **Command**: $COMMAND

          $RESPONSE

          ---
          *Generated by Gemini CLI in response to your request.*
          EOF

          # Post comment to appropriate location
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # Direct PR comment
            gh pr comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "âœ… Custom command processed for PR #$ISSUE_NUMBER"
          else
            # Issue comment - but also comment on existing PR if one exists
            gh issue comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "âœ… Custom command processed for issue #$ISSUE_NUMBER"
            
            # If there's an existing PR, also post the response there for visibility
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              cat > /tmp/pr_update_comment.md << EOF
          ## ðŸ”„ Issue Update from #$ISSUE_NUMBER

          A follow-up comment was made on issue #$ISSUE_NUMBER:

          > **@gemini Command**: $COMMAND

          $RESPONSE

          ---
          *This update was automatically posted from issue #$ISSUE_NUMBER*
          EOF
              gh pr comment $EXISTING_PR_NUMBER --body-file /tmp/pr_update_comment.md
              echo "ðŸ“‹ Also posted update to existing PR #$EXISTING_PR_NUMBER"
            fi
          fi

      - name: Visual Verification and Browser Testing
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && contains(github.event.comment.body, 'visual')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && contains(github.event.comment.body, 'visual'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
        run: |
          echo "ðŸŽ¨ Starting visual verification and browser testing..."
          
          # Create screenshots directory
          mkdir -p .screenshots/before .screenshots/after
          
          # Start development server in background (if package.json exists)
          if [ -f "package.json" ]; then
            echo "ðŸ“¦ Starting development server..."
            
            # Install dependencies
            if command -v bun >/dev/null 2>&1; then
              bun install
              timeout 30s bun run dev &
            else
              npm install
              timeout 30s npm run dev &
            fi
            
            DEV_PID=$!
            sleep 10  # Wait for server to start
            
            echo "ðŸŒ Development server started (PID: $DEV_PID)"
          fi
          
          # Configure MCP browser automation prompt
          cat > /tmp/visual_verification_prompt.txt << EOF
          You are a senior QA engineer with expertise in visual testing and browser automation.
          
          **MISSION:** Perform comprehensive visual verification of web improvements using MCP browser automation.
          
          ## Available Tools:
          - Playwright MCP server for browser automation
          - Screenshot capture capabilities
          - Visual comparison and analysis
          
          ## Visual Testing Tasks:
          
          1. **Take Screenshots of Key Pages:**
             - Homepage (http://localhost:3000)
             - Product pages
             - Navigation components
             - Mobile responsive views (375px, 768px, 1920px)
          
          2. **Verify Visual Improvements:**
             - Layout consistency across viewports
             - Typography and spacing
             - Color scheme and accessibility
             - Interactive elements (buttons, forms, animations)
             - Loading states and transitions
          
          3. **Browser Compatibility Testing:**
             - Test in Chromium (primary)
             - Capture any visual inconsistencies
             - Verify responsive design breakpoints
          
          4. **Generate Visual Report:**
             - Create before/after comparisons if applicable
             - Document any visual issues found
             - Provide specific recommendations for improvements
             - Include screenshots as evidence
          
          ## Context:
          - Repository: Neural Arc Website
          - Technology: React.js with 3D animations and modern UI
          - PR/Issue: #$PR_NUMBER
          
          **DELIVERABLES:**
          1. Screenshots saved to .screenshots/ directory
          2. Visual testing report with findings
          3. Specific recommendations for any issues
          4. Browser compatibility assessment
          
          Use the MCP Playwright server to automate browser interactions and capture comprehensive visual evidence.
          Focus on user experience and visual quality assurance.
          EOF
          
          # Run visual verification with Gemini + MCP
          echo "ðŸ¤– Running AI-powered visual verification..."
          VISUAL_REPORT=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/visual_verification_prompt.txt)")
          
          # Kill development server if it was started
          if [ ! -z "$DEV_PID" ]; then
            kill $DEV_PID 2>/dev/null || true
            echo "ðŸ”´ Development server stopped"
          fi
          
          # Create visual verification report
          cat > /tmp/visual_report.md << EOF
          ## ðŸŽ¨ Visual Verification Report
          
          **Automated by Gemini CLI with MCP Browser Automation**
          
          ### Test Environment
          - Browser: Chromium (Playwright)
          - Viewports: Mobile (375px), Tablet (768px), Desktop (1920px)
          - Local Server: http://localhost:3000
          
          ### Visual Analysis Results
          $VISUAL_REPORT
          
          ### Screenshots
          Screenshots have been captured and saved to the repository's .screenshots directory.
          
          ---
          *Generated by Gemini CLI with MCP Playwright integration for PR/Issue #$PR_NUMBER*
          EOF
          
          # Post visual report as comment
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            gh pr comment $PR_NUMBER --body-file /tmp/visual_report.md
            echo "âœ… Visual verification report posted to PR #$PR_NUMBER"
          else
            gh issue comment $PR_NUMBER --body-file /tmp/visual_report.md
            echo "âœ… Visual verification report posted to issue #$PR_NUMBER"
          fi
          
          # Commit screenshots if any were created
          if [ -n "$(find .screenshots -type f -name '*.png' 2>/dev/null)" ]; then
            git add .screenshots/
            git commit -m "ðŸ“¸ Add visual verification screenshots for #$PR_NUMBER" || true
            git push origin HEAD || true
            echo "ðŸ“¸ Screenshots committed to repository"
          fi
          
          echo "ðŸŽ¨ Visual verification completed"

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/*.txt /tmp/*.md
          # Preserve screenshots directory for visual verification
          echo "ðŸ§¹ Cleanup completed (screenshots preserved)"

      - name: Report Status
        if: always()
        run: |
          echo "ðŸ“Š Gemini CLI Automation Summary:"
          echo "- Event: ${{ github.event_name }}"
          echo "- Action: ${{ github.event.action }}"
          echo "- Issue/PR: #${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "- Status: ${{ job.status }}"