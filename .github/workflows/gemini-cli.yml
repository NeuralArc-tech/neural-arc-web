name: Custom AI Integration

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  discussions: write
  id-token: write

jobs:
  ai-automation:
    name: Custom AI Automation
    runs-on: ubuntu-latest

    # Only run for users with proper permissions and @gemini mentions
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install project dependencies
        run: |
          bun install
          echo "Project dependencies installed successfully"

      - name: Setup Custom AI API
        run: |
          echo "Using custom AI API endpoint: https://genapi.ashari.cloud"
          echo "API configured successfully"

      - name: Configure Environment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git for commits
          git config --global user.name "Gemini CLI Bot"
          git config --global user.email "gemini-cli@github-actions.noreply.com"

          # Verify environment setup
          echo "🔧 Environment Setup:"
          echo "- Node version: $(node --version)"
          echo "- Bun version: $(bun --version)"
          echo "- NPM version: $(npm --version)"
          echo "- Git version: $(git --version)"
          echo "- GitHub CLI version: $(gh --version | head -1)"
          echo "- Current directory: $(pwd)"
          echo "- Repository: ${{ github.repository }}"

          # Verify project commands work
          echo ""
          echo "📦 Available Project Commands:"
          bun run --help 2>/dev/null | grep -E "dev|build|lint|test|type-check" || echo "Project scripts from package.json:"
          cat package.json | jq -r '.scripts' 2>/dev/null || echo "No scripts found"

          # Create AI API function
          cat > /tmp/call_ai_api.sh << 'EOF'
          #!/bin/bash
          call_ai_api() {
            local prompt="$1"
            local max_retries=3
            local retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              # Create proper JSON payload using jq to handle escaping
              local json_payload=$(jq -n \
                --arg content "$prompt" \
                '{
                  "messages": [
                    {
                      "content": $content,
                      "role": "user"
                    }
                  ]
                }')
              
              # Call custom AI API with better error handling
              local response=$(curl -s --location 'https://genapi.ashari.cloud/v1/chat/completions' \
                --header 'User-Agent: BrainyBuddy-API/bandung' \
                --header 'Content-Type: application/json' \
                --data "$json_payload" 2>/dev/null)
              
              echo "API Response received, validating..." >&2
              
              # Check if response is valid JSON with expected structure
              if echo "$response" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
                echo "API call successful!" >&2
                echo "$response" | jq -r '.choices[0].message.content'
                return 0
              else
                echo "API error - Invalid response format: ${response:0:300}..." >&2
              fi
              
              retry_count=$((retry_count + 1))
              echo "API call failed, retrying... ($retry_count/$max_retries)" >&2
              sleep $((retry_count * 2))
            done
            
            echo "ERROR: AI API calls failed after $max_retries attempts" >&2
            return 1
          }
          EOF
          
          chmod +x /tmp/call_ai_api.sh
          source /tmp/call_ai_api.sh

      - name: Issue Triage
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "🔍 Analyzing issue #$ISSUE_NUMBER for automated triage..."

          # Get all issue comments for full context
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)

          # Extract attachment URLs from issue body
          ISSUE_ATTACHMENTS=$(echo "$ISSUE_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          ISSUE_USER_CONTENT=$(echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          ISSUE_GITHUB_UPLOADS=$(echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Extract attachment URLs from all comments
          COMMENT_ATTACHMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          COMMENT_USER_CONTENT=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          COMMENT_GITHUB_UPLOADS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Combine all attachments
          ALL_ATTACHMENTS=$(echo -e "$ISSUE_ATTACHMENTS\n$ISSUE_USER_CONTENT\n$ISSUE_GITHUB_UPLOADS\n$COMMENT_ATTACHMENTS\n$COMMENT_USER_CONTENT\n$COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Get repository file structure for context
          REPO_STRUCTURE=$(find . -type f -name "*.json" -o -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$|^\\./src/" | head -30 | sort)

          # Get key project files content
          README_SNIPPET=$(head -20 README.md 2>/dev/null || echo "No README.md found")
          GEMINI_CONFIG=$(head -50 GEMINI.md 2>/dev/null || echo "No GEMINI.md found")

          # Create a comprehensive prompt for issue analysis
          cat > /tmp/issue_analysis_prompt.txt << EOF
          You are the Gemini AI assistant integrated into this GitHub repository with both analytical and autonomous implementation capabilities.

          **YOUR DUAL ROLE:**
          1. **GEMINI AI ASSISTANT**: When users request "@gemini [analysis/review/help]", provide helpful analysis and reports
          2. **AUTONOMOUS ENGINEER**: When issues require code implementation, you can autonomously implement solutions

          **ENVIRONMENT & TOOLS AVAILABLE:**
          - Node.js 20.x with npm
          - Bun (latest) - primary package manager and runtime
          - Git and GitHub CLI (gh) for version control
          - Full file system access in repository: ${{ github.repository }}
          - Project type: Next.js 15+ with TypeScript, Tailwind CSS, deployed on Cloudflare Workers
          - All project dependencies are installed via 'bun install'
          - Build commands: bun run dev, bun run build, bun run lint, bun run type-check

          **DECISION LOGIC:**
          - If user asks "@gemini review/analyze/help" → Provide analysis and helpful insights
          - If issue requests specific implementation → Implement the solution autonomously
          - If issue needs clarification → Ask questions and provide guidance
          - Make technical decisions based on engineering best practices

          ## Repository Structure
          Key files and directories in this project:
          $REPO_STRUCTURE

          ## Project Configuration (GEMINI.md)
          $GEMINI_CONFIG

          ## Issue Context

          **Issue #$ISSUE_NUMBER Title**: "$ISSUE_TITLE"
          **Issue URL**: https://github.com/${{ github.repository }}/issues/$ISSUE_NUMBER
          **Created by**: ${{ github.event.issue.user.login }}

          **Issue Description**: 
          $ISSUE_BODY

          **All Comments and Discussion**:
          $ISSUE_COMMENTS

          **Issue Labels**: ${{ github.event.issue.labels }}

          ## Attachments and Files
          $(if [ ! -z "$ALL_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this issue/comments:**"
            echo "$ALL_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this issue."
          fi)

          ## RESPONSE DECISION TREE

          **ANALYZE & REPORT** when:
          - User specifically asks "@gemini review/analyze/help/explain"
          - Issue is asking for project analysis, bug identification, or recommendations
          - User wants understanding of existing code or architecture
          - Request is for insights, suggestions, or explanations

          **IMPLEMENT CODE** when:
          - Issue requests specific features, bug fixes, or changes
          - Documentation updates or additions needed
          - Configuration changes required
          - UI component additions or modifications needed
          - Style improvements or responsive fixes requested
          - Code refactoring or optimization requested

          ## FOR ANALYSIS REQUESTS:
          Provide comprehensive analysis including:
          - Project overview and current state
          - Potential issues or improvements identified
          - Architecture recommendations
          - Code quality assessment
          - Security considerations
          - Performance optimization suggestions

          ## FOR IMPLEMENTATION REQUESTS:
          1. Create a descriptive branch name (feature/issue-${ISSUE_NUMBER}-[short-description])
          2. Implement the solution completely - don't do partial implementations
          3. Write clean, working code (quality checks can be done later)
          4. Stage and commit with conventional commit message
          5. Push the branch to origin
          6. Create PR using: gh pr create --title "[Creative Title]" --body "[Compelling description that closes #${ISSUE_NUMBER}]"
          7. SHIP THE CODE - don't get blocked by tooling issues

          **Response Format:**
          Priority: [level]
          Labels: [comma-separated list]
          Difficulty: [level]

          ## Analysis
          [Provide the requested analysis or technical explanation]

          ## Implementation Status
          Choose ONE based on the request type:
          - 📊 ANALYSIS PROVIDED: [Comprehensive analysis and recommendations completed]
          - ✅ NEW CODE SHIPPED: [Description of new code you created + PR URL]
          - 🔄 ALREADY EXISTS: [Feature already implemented, no changes needed]
          - ❌ BLOCKED: [Specific technical reason why you cannot complete the request]

          **Remember: You are the Gemini AI assistant. Provide the analysis or implementation the user requested.**
          EOF

          # Load AI API function
          source /tmp/call_ai_api.sh
          
          # Run AI analysis with custom API
          echo "🤖 Calling custom AI API for analysis..."
          ANALYSIS=$(call_ai_api "$(cat /tmp/issue_analysis_prompt.txt)")

          # Extract labels from analysis with better error handling
          if [ ! -z "$ANALYSIS" ] && [ "$ANALYSIS" != "ERROR: AI API calls failed after 3 attempts" ]; then
            PRIORITY=$(echo "$ANALYSIS" | grep -i "Priority:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            LABELS=$(echo "$ANALYSIS" | grep -i "Labels:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            DIFFICULTY=$(echo "$ANALYSIS" | grep -i "Difficulty:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Apply labels using GitHub CLI with proper quoting
            if [ ! -z "$LABELS" ]; then
              # Clean up labels and split by comma
              echo "$LABELS" | tr ',' '\n' | while read -r label; do
                # Clean label of quotes and whitespace
                clean_label=$(echo "$label" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/^"//' | sed 's/"$//')
                if [ ! -z "$clean_label" ]; then
                  gh issue edit $ISSUE_NUMBER --add-label "$clean_label" || echo "Could not add label: $clean_label"
                fi
              done
            fi

            # Add priority and difficulty labels with proper quoting
            if [ ! -z "$PRIORITY" ]; then
              clean_priority=$(echo "$PRIORITY" | sed 's/^"//' | sed 's/"$//')
              gh issue edit $ISSUE_NUMBER --add-label "priority: $clean_priority" || true
            fi
            
            if [ ! -z "$DIFFICULTY" ]; then
              clean_difficulty=$(echo "$DIFFICULTY" | sed 's/^"//' | sed 's/"$//')
              gh issue edit $ISSUE_NUMBER --add-label "difficulty: $clean_difficulty" || true
            fi
          else
            echo "⚠️ AI analysis failed, skipping automatic labeling"
          fi

          # Post analysis as comment
          cat > /tmp/comment.md << EOF
          ## 🤖 Automated Issue Analysis

          $ANALYSIS

          ---
          *This analysis was generated by Gemini CLI. Human review recommended.*
          EOF

          gh issue comment $ISSUE_NUMBER --body-file /tmp/comment.md

          echo "✅ Issue triage completed for #$ISSUE_NUMBER"

      - name: Pull Request Review
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
        run: |
          echo "🔍 Analyzing pull request #$PR_NUMBER..."

          # Get PR details with full context
          PR_DETAILS=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,commits)
          PR_TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
          PR_BODY=$(echo "$PR_DETAILS" | jq -r '.body // ""')

          # Get all PR comments and reviews for full context
          PR_COMMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
          PR_REVIEWS=$(gh pr view $PR_NUMBER --json reviews --jq '.reviews[] | "\(.author.login) (\(.submittedAt)) - \(.state): \(.body // "No comment")"' | head -10)

          # Get changed files
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)

          # Extract attachment URLs from PR body and comments
          PR_ATTACHMENTS=$(echo "$PR_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_USER_CONTENT=$(echo "$PR_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_GITHUB_UPLOADS=$(echo "$PR_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          PR_COMMENT_ATTACHMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_COMMENT_USER_CONTENT=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_COMMENT_GITHUB_UPLOADS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          ALL_PR_ATTACHMENTS=$(echo -e "$PR_ATTACHMENTS\n$PR_USER_CONTENT\n$PR_GITHUB_UPLOADS\n$PR_COMMENT_ATTACHMENTS\n$PR_COMMENT_USER_CONTENT\n$PR_COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Create comprehensive PR analysis prompt
          cat > /tmp/pr_analysis_prompt.txt << EOF
          You are a senior code reviewer for a full-stack web application workspace.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - PR #$PR_NUMBER URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER
          - Project: Next.js 15+ with TypeScript, Tailwind CSS, Cloudflare Workers deployment
          - Available tools: Node.js, Bun, Git, GitHub CLI
          - Can run: bun test, bun lint, bun type-check to verify changes

          Review this pull request and provide:
          1. **Code Quality Assessment**: Rate 1-5 and explain
          2. **Security Concerns**: Any potential security issues
          3. **Performance Impact**: Potential performance implications
          4. **Architecture Alignment**: How well it fits the existing architecture
          5. **Testing Requirements**: What tests should be added/updated
          6. **Specific Feedback**: Line-by-line suggestions for improvement

          ## PR Details
          **PR #$PR_NUMBER Title**: "$PR_TITLE"
          **Author**: ${{ github.event.pull_request.user.login || github.actor }}
          **PR Description**: "$PR_BODY"

          **Changed Files**:
          $CHANGED_FILES

          ## Full Conversation Context
          **PR Comments**:
          $PR_COMMENTS

          **PR Reviews**:
          $PR_REVIEWS

          **Current User Comment**: "$COMMENT_BODY"

          ## Attachments and Files in PR
          $(if [ ! -z "$ALL_PR_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this PR/comments:**"
            echo "$ALL_PR_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**You can download and analyze these files if relevant to the code review:**"
            echo "- Images: May contain UI designs, screenshots, or visual bugs"
            echo "- Files: May contain test data, configurations, or documentation"
            echo "Use: curl -L -o filename 'URL' to download"
          else
            echo "No attachments found in this PR."
          fi)

          Provide constructive, actionable feedback focusing on:
          - Code quality and best practices
          - Security implications
          - Performance considerations  
          - Maintainability
          - Testing coverage

          Consider the full conversation history when providing your review. Reference previous comments and reviews when relevant.
          Be specific and helpful. If the code looks good, say so!
          EOF

          # Get the actual diff for detailed analysis
          PR_DIFF=$(gh pr diff $PR_NUMBER)

          # Create diff analysis file
          cat > /tmp/diff_analysis_prompt.txt << EOF
          $(cat /tmp/pr_analysis_prompt.txt)

          Here is the actual code diff:
          \`\`\`diff
          $PR_DIFF
          \`\`\`

          Please provide a detailed code review.
          EOF

          # Load AI API function and run analysis
          source /tmp/call_ai_api.sh
          echo "🤖 Calling custom AI API for PR review..."
          REVIEW=$(call_ai_api "$(cat /tmp/diff_analysis_prompt.txt)")

          # Post review as comment
          cat > /tmp/review_comment.md << EOF
          ## 🤖 Automated Code Review

          $REVIEW

          ---
          *This review was generated by Gemini CLI. Human review still recommended for final approval.*
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/review_comment.md

          echo "✅ Pull request review completed for #$PR_NUMBER"

      - name: Custom Gemini Commands
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          echo "🤖 Processing custom Gemini command..."

          # Extract command from comment (everything after @gemini)
          COMMAND=$(echo "$COMMENT_BODY" | sed -n 's/.*@gemini[[:space:]]*\(.*\)/\1/p' | head -n1)

          if [ -z "$COMMAND" ]; then
            COMMAND="Please provide assistance with this issue/PR"
          fi

          echo "Command: $COMMAND"

          # Get repository context for better understanding
          REPO_FILES=$(find . -type f -name "*.json" -o -name "*.ts" -o -name "*.tsx" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$|^\\./src/" | head -20 | sort)
          PROJECT_INFO=$(cat package.json 2>/dev/null | jq -r '{name, version, description, scripts}' || echo "No package.json")
          GEMINI_CONTEXT=$(cat GEMINI.md 2>/dev/null || echo "No GEMINI.md found")

          # Extract attachment URLs from the current comment
          CURRENT_ATTACHMENTS=$(echo "$COMMENT_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          CURRENT_USER_CONTENT=$(echo "$COMMENT_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          CURRENT_GITHUB_UPLOADS=$(echo "$COMMENT_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Get context (issue or PR details with full conversation)
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # This is a PR
            CONTEXT=$(gh pr view $ISSUE_NUMBER --json title,body,files,state)
            CONTEXT_TYPE="pull request"
            # Get PR comments for full context
            COMMENTS=$(gh pr view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            EXISTING_PR_NUMBER=$ISSUE_NUMBER
          else
            # This is an issue - check if it has an associated PR
            CONTEXT=$(gh issue view $ISSUE_NUMBER --json title,body,state,labels)
            CONTEXT_TYPE="issue"
            # Get issue comments for full context
            COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            
            # Check for existing PR that closes this issue
            EXISTING_PR_NUMBER=$(gh pr list --search "closes #$ISSUE_NUMBER" --json number --jq '.[0].number // empty' 2>/dev/null || echo "")
            
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              echo "📋 Found existing PR #$EXISTING_PR_NUMBER that addresses issue #$ISSUE_NUMBER"
              # Get existing PR details for context
              EXISTING_PR_CONTEXT=$(gh pr view $EXISTING_PR_NUMBER --json title,body,headRefName,state,mergedAt)
              EXISTING_PR_STATE=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.state')
              EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.headRefName')
              
              if [ "$EXISTING_PR_STATE" = "MERGED" ]; then
                echo "✅ PR #$EXISTING_PR_NUMBER was already merged - will create new PR for follow-up changes"
                EXISTING_PR_MERGED=true
              else
                echo "🌟 Will update existing PR branch: $EXISTING_PR_BRANCH"
                EXISTING_PR_MERGED=false
              fi
              
              # Get PR file changes for context
              EXISTING_PR_FILES=$(gh pr view $EXISTING_PR_NUMBER --json files --jq '.files[] | "\(.path): \(.additions)+ \(.deletions)-"')
              
              # Get PR comments for full context  
              EXISTING_PR_COMMENTS=$(gh pr view $EXISTING_PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -10)
            fi
          fi

          # Create context-aware prompt with existing PR information
          cat > /tmp/custom_command_prompt.txt << EOF
          You are a senior full-stack engineer working on a GitHub repository with full access to modify files and create pull requests.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - Working Directory: $(pwd)
          - Node.js, Bun, Git, and GitHub CLI are available
          - Project: Next.js 15+ with TypeScript, Tailwind CSS
          - All dependencies installed, can run: bun dev, bun build, bun test, bun lint
          - Project files: README.md, GEMINI.md contain project documentation

          Context: You are responding to a comment on $CONTEXT_TYPE #$ISSUE_NUMBER

          ## Project Information
          **Repository Files**: 
          $REPO_FILES

          **Package Info**:
          $PROJECT_INFO

          ## $CONTEXT_TYPE Details:
          $CONTEXT

          ## Full Conversation History:
          $COMMENTS

          ## Current User Request: 
          "$COMMAND"

          ## Attachments in this Comment
          $(if [ ! -z "$CURRENT_ATTACHMENTS$CURRENT_USER_CONTENT$CURRENT_GITHUB_UPLOADS" ]; then
            echo "**Attachments found in this comment:**"
            [ ! -z "$CURRENT_ATTACHMENTS" ] && echo "$CURRENT_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_USER_CONTENT" ] && echo "$CURRENT_USER_CONTENT" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_GITHUB_UPLOADS" ] && echo "$CURRENT_GITHUB_UPLOADS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this comment."
          fi)
          EOF

          # Add existing PR instructions if applicable
          if [ ! -z "$EXISTING_PR_NUMBER" ] && [ "$CONTEXT_TYPE" = "issue" ]; then
            if [ "$EXISTING_PR_MERGED" = "true" ]; then
              cat >> /tmp/custom_command_prompt.txt << EOF

          ## 🎉 PREVIOUS PR WAS MERGED - CREATE NEW PR FOR FOLLOW-UP
          There was a previous PR #$EXISTING_PR_NUMBER that addressed this issue and was merged.

          **PREVIOUS PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES THAT WERE CHANGED:**
          $EXISTING_PR_FILES

          **PREVIOUS PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **CREATE NEW PR FOR FOLLOW-UP CHANGES:**
          1. You're already on main branch with the merged changes
          2. Create a new branch: git checkout -b feature/issue-${ISSUE_NUMBER}-followup-[description]
          3. Make the requested changes to the files (they now contain the merged content)
          4. Stage changes: git add .
          5. Commit with clear message: "docs: [describe your changes]"
          6. Push the new branch: git push origin [branch-name]
          7. Create NEW PR: gh pr create --title "[Creative Title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. Provide the PR URL in your response

          **The files now contain the merged content from the previous PR - work with that as your starting point.**
          EOF
            else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## 🚨 IMPORTANT: Existing PR Found
          There is already an existing PR #$EXISTING_PR_NUMBER that addresses this issue.

          **EXISTING PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES CHANGED IN EXISTING PR:**
          $EXISTING_PR_FILES

          **EXISTING PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **🚨 CRITICAL: EXECUTE GIT COMMANDS FIRST - DO NOT SKIP!**

          YOU MUST EXECUTE THESE EXACT COMMANDS BEFORE DOING ANYTHING:

          1. git fetch origin --all
          2. git checkout -B $EXISTING_PR_BRANCH origin/$EXISTING_PR_BRANCH  
          3. git branch --show-current

          VERIFY: The output of step 3 must show "$EXISTING_PR_BRANCH"

          4. head -10 README.md

          VERIFY: This should show the PR version (with Table of Contents), NOT the main branch version

          **IF YOU DON'T SEE THE TABLE OF CONTENTS SECTION, YOU'RE ON THE WRONG BRANCH!**

          Expected content in PR branch README.md:
          - Should start with "# Asharitech Web" 
          - Should have "## Table of Contents" section around line 8-10
          - Should have CI Build Status badges
          - Should be much longer than main branch version

          Only after successfully checking out $EXISTING_PR_BRANCH and verifying the content:
          5. Make your requested changes to the files
          6. git add .
          7. git commit -m "docs: [describe your changes]"
          8. git push origin $EXISTING_PR_BRANCH

          **FAILURE PREVENTION:**
          - Main branch README starts with "# Ashari Tech - Corporate Website"
          - PR branch README starts with "# Asharitech Web" 
          - If you see the wrong title, you're on main branch - STOP and fix checkout!

          **DO NOT CREATE NEW PR** - Update existing: https://github.com/asharitech/asharitech-web/pull/$EXISTING_PR_NUMBER

          **SHIP THE CODE NOW - We can iterate and improve later if needed.**
          EOF
            fi
          else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## AUTONOMOUS ENGINEERING MODE - SHIP CODE NOW

          **YOU ARE A SENIOR FULL-STACK ENGINEER WITH COMPLETE AUTONOMY**

          **CORE ENGINEERING PRINCIPLES:**
          - Make decisions immediately based on technical merit
          - Ship working code - don't overthink or ask permission
          - We're in git - breaking changes are recoverable via rollback
          - Trust your senior engineering judgment
          - Favor rapid iteration over perfect planning
          - Implement complete solutions, not partial fixes
          - NEVER use force push (git push -f) - preserve commit history
          - Always add new commits, don't overwrite existing ones

          **WHEN USER REQUESTS CHANGES - IMPLEMENT IMMEDIATELY:**
          1. Create a descriptive branch: feature/[meaningful-name]
          2. Implement the complete solution (no partial work)
          3. Write working code - focus on functionality over perfection
          4. Stage all changes: git add .
          5. Commit with conventional message: "feat: implement [feature]" or "fix: resolve [issue]"
          6. Push branch: git push origin [branch-name] (NEVER use --force)
          7. Create PR: gh pr create --title "[Creative, compelling title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. SHIP IT - don't get blocked by tooling or linting issues
          9. Report the PR URL immediately

          **IMPLEMENTATION SCOPE - BE AGGRESSIVE:**
          - UI components and styling changes
          - New features and functionality
          - Bug fixes and improvements
          - Documentation updates
          - Configuration changes
          - Code refactoring and optimization
          - Dependency management
          - Build and deployment improvements

          **DON'T ASK - JUST DO IT. Senior engineers ship code and iterate quickly.**
          EOF
          fi

          # Add common instructions
          cat >> /tmp/custom_command_prompt.txt << EOF

          If gh CLI fails, capture the exact error message and include it in your response.

          For other requests, provide helpful, actionable responses with specific examples.
          Focus on being practical and specific to this codebase context.
          EOF

          # Load AI API function and run analysis
          source /tmp/call_ai_api.sh
          echo "🤖 Calling custom AI API for command processing..."
          RESPONSE=$(call_ai_api "$(cat /tmp/custom_command_prompt.txt)")

          # Post response as comment
          cat > /tmp/response_comment.md << EOF
          ## 🤖 Gemini Response

          > **Command**: $COMMAND

          $RESPONSE

          ---
          *Generated by Gemini CLI in response to your request.*
          EOF

          # Post comment to appropriate location
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # Direct PR comment
            gh pr comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for PR #$ISSUE_NUMBER"
          else
            # Issue comment - but also comment on existing PR if one exists
            gh issue comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for issue #$ISSUE_NUMBER"
            
            # If there's an existing PR, also post the response there for visibility
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              cat > /tmp/pr_update_comment.md << EOF
          ## 🔄 Issue Update from #$ISSUE_NUMBER

          A follow-up comment was made on issue #$ISSUE_NUMBER:

          > **@gemini Command**: $COMMAND

          $RESPONSE

          ---
          *This update was automatically posted from issue #$ISSUE_NUMBER*
          EOF
              gh pr comment $EXISTING_PR_NUMBER --body-file /tmp/pr_update_comment.md
              echo "📋 Also posted update to existing PR #$EXISTING_PR_NUMBER"
            fi
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/*.txt /tmp/*.md
          echo "🧹 Cleanup completed"

      - name: Report Status
        if: always()
        run: |
          echo "📊 Gemini CLI Automation Summary:"
          echo "- Event: ${{ github.event_name }}"
          echo "- Action: ${{ github.event.action }}"
          echo "- Issue/PR: #${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "- Status: ${{ job.status }}"