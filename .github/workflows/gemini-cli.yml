name: Custom AI Integration

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  discussions: write
  id-token: write

jobs:
  ai-automation:
    name: Custom AI Automation
    runs-on: ubuntu-latest

    # Only run for users with proper permissions and @gemini mentions
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install project dependencies
        run: |
          bun install
          echo "Project dependencies installed successfully"

      - name: Setup Custom AI API
        run: |
          echo "Using custom AI API endpoint: https://genapi.ashari.cloud"
          echo "API configured successfully"

      - name: Configure Environment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git for commits
          git config --global user.name "Gemini CLI Bot"
          git config --global user.email "gemini-cli@github-actions.noreply.com"

          # Verify environment setup
          echo "ðŸ”§ Environment Setup:"
          echo "- Node version: $(node --version)"
          echo "- Bun version: $(bun --version)"
          echo "- NPM version: $(npm --version)"
          echo "- Git version: $(git --version)"
          echo "- GitHub CLI version: $(gh --version | head -1)"
          echo "- Current directory: $(pwd)"
          echo "- Repository: ${{ github.repository }}"

          # Verify project commands work
          echo ""
          echo "ðŸ“¦ Available Project Commands:"
          bun run --help 2>/dev/null | grep -E "dev|build|lint|test|type-check" || echo "Project scripts from package.json:"
          cat package.json | jq -r '.scripts' 2>/dev/null || echo "No scripts found"

          # Create AI API function
          cat > /tmp/call_ai_api.sh << 'EOF'
          #!/bin/bash
          call_ai_api() {
            local prompt="$1"
            local max_retries=3
            local retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              # Create proper JSON payload using jq to handle escaping
              local json_payload=$(jq -n \
                --arg content "$prompt" \
                '{
                  "messages": [
                    {
                      "content": $content,
                      "role": "user"
                    }
                  ]
                }')
              
              # Call custom AI API with better error handling
              local response=$(curl -s --location 'https://genapi.ashari.cloud/v1/chat/completions' \
                --header 'User-Agent: BrainyBuddy-API/bandung' \
                --header 'Content-Type: application/json' \
                --data "$json_payload" 2>/dev/null)
              
              echo "API Response received, validating..." >&2
              
              # Check if response is valid JSON with expected structure
              if echo "$response" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
                echo "API call successful!" >&2
                echo "$response" | jq -r '.choices[0].message.content'
                return 0
              else
                echo "API error - Invalid response format: ${response:0:300}..." >&2
              fi
              
              retry_count=$((retry_count + 1))
              echo "API call failed, retrying... ($retry_count/$max_retries)" >&2
              sleep $((retry_count * 2))
            done
            
            echo "ERROR: AI API calls failed after $max_retries attempts" >&2
            return 1
          }
          EOF
          
          chmod +x /tmp/call_ai_api.sh
          source /tmp/call_ai_api.sh

      - name: Issue Triage
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "ðŸ” Analyzing issue #$ISSUE_NUMBER for automated triage..."

          # Get all issue comments for full context
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)

          # Extract attachment URLs from issue body
          ISSUE_ATTACHMENTS=$(echo "$ISSUE_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          ISSUE_USER_CONTENT=$(echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          ISSUE_GITHUB_UPLOADS=$(echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Extract attachment URLs from all comments
          COMMENT_ATTACHMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          COMMENT_USER_CONTENT=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          COMMENT_GITHUB_UPLOADS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Combine all attachments
          ALL_ATTACHMENTS=$(echo -e "$ISSUE_ATTACHMENTS\n$ISSUE_USER_CONTENT\n$ISSUE_GITHUB_UPLOADS\n$COMMENT_ATTACHMENTS\n$COMMENT_USER_CONTENT\n$COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Get repository file structure for context
          REPO_STRUCTURE=$(find . -type f -name "*.json" -o -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$|^\\./src/" | head -30 | sort)

          # Get key project files content
          README_SNIPPET=$(head -20 README.md 2>/dev/null || echo "No README.md found")
          GEMINI_CONFIG=$(head -50 GEMINI.md 2>/dev/null || echo "No GEMINI.md found")
          
          # Get existing labels from the repository
          EXISTING_LABELS=$(gh label list --json name,description --jq '.[] | "\(.name) - \(.description)"' | head -20)
          LABEL_NAMES_ONLY=$(gh label list --json name --jq '.[].name' | paste -sd ',' -)

          # Create a comprehensive prompt for issue analysis
          cat > /tmp/issue_analysis_prompt.txt << EOF
          You are the Gemini AI assistant integrated into this GitHub repository with both analytical and autonomous implementation capabilities.

          **YOUR DUAL ROLE:**
          1. **GEMINI AI ASSISTANT**: When users request "@gemini [analysis/review/help]", provide helpful analysis and reports
          2. **AUTONOMOUS ENGINEER**: When issues require code implementation, you can autonomously implement solutions

          **ENVIRONMENT & TOOLS AVAILABLE:**
          - Node.js 20.x with npm
          - Bun (latest) - primary package manager and runtime
          - Git and GitHub CLI (gh) for version control
          - Full file system access in repository: ${{ github.repository }}
          - Project type: Next.js 15+ with TypeScript, Tailwind CSS, deployed on Cloudflare Workers
          - All project dependencies are installed via 'bun install'
          - Build commands: bun run dev, bun run build, bun run lint, bun run type-check

          **DECISION LOGIC:**
          - If user asks "@gemini review/analyze/help" â†’ Provide analysis and helpful insights
          - If issue requests specific implementation â†’ Implement the solution autonomously
          - If issue needs clarification â†’ Ask questions and provide guidance
          - Make technical decisions based on engineering best practices

          ## Repository Structure
          Key files and directories in this project:
          $REPO_STRUCTURE

          ## Project Configuration (GEMINI.md)
          $GEMINI_CONFIG

          ## Issue Context

          **Issue #$ISSUE_NUMBER Title**: "$ISSUE_TITLE"
          **Issue URL**: https://github.com/${{ github.repository }}/issues/$ISSUE_NUMBER
          **Created by**: ${{ github.event.issue.user.login }}

          **Issue Description**: 
          $ISSUE_BODY

          **All Comments and Discussion**:
          $ISSUE_COMMENTS

          **Issue Labels**: ${{ github.event.issue.labels }}

          ## Attachments and Files
          $(if [ ! -z "$ALL_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this issue/comments:**"
            echo "$ALL_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this issue."
          fi)

          ## RESPONSE DECISION TREE

          **ANALYZE & REPORT** when:
          - User specifically asks "@gemini review/analyze/help/explain"
          - Issue is asking for project analysis, bug identification, or recommendations
          - User wants understanding of existing code or architecture
          - Request is for insights, suggestions, or explanations

          **IMPLEMENT CODE** when:
          - Issue requests specific features, bug fixes, or changes
          - Documentation updates or additions needed
          - Configuration changes required
          - UI component additions or modifications needed
          - Style improvements or responsive fixes requested
          - Code refactoring or optimization requested

          ## FOR ANALYSIS REQUESTS:
          Provide comprehensive analysis including:
          - Project overview and current state
          - Potential issues or improvements identified
          - Architecture recommendations
          - Code quality assessment
          - Security considerations
          - Performance optimization suggestions
          
          **MANDATORY: After providing analysis, if you have actionable recommendations:**
          - ALWAYS include this exact section: "## ðŸš€ Ready for Implementation"
          - List specific actionable changes that can be implemented
          - ALWAYS end with this exact text: "To implement these recommendations, please comment: @gemini implement these recommendations"
          - This is REQUIRED - do not ask for approval, just provide the implementation command

          ## FOR IMPLEMENTATION REQUESTS:
          ðŸš¨ **NEVER APPLY CHANGES TO MASTER BRANCH - ALWAYS USE FEATURE BRANCHES** ðŸš¨
          
          1. Verify not on master: git branch --show-current (must NOT be master/main)
          2. Create a descriptive branch name (feature/issue-${ISSUE_NUMBER}-[short-description])
          3. Implement the solution completely - don't do partial implementations
          4. Write clean, working code (quality checks can be done later)
          5. Stage and commit with conventional commit message
          6. Push the branch to origin
          7. Create PR using: gh pr create --title "[Creative Title]" --body "[Compelling description that closes #${ISSUE_NUMBER}]"
          8. SHIP THE CODE - don't get blocked by tooling issues
          
          **BRANCH PROTECTION: All changes must go through PRs, never direct to master**
          
          **PROVIDE IMPLEMENTATION IN THIS FORMAT:**
          
          IMPLEMENTATION COMMANDS:
          git checkout -b feature/issue-${ISSUE_NUMBER}-description
          git add .
          git commit -m "feat: implement feature description"
          git push origin feature/issue-${ISSUE_NUMBER}-description
          gh pr create --title "Title" --body "Description closes #${ISSUE_NUMBER}"
          END COMMANDS
          
          **For file creation/modification:**
          
          FILE: path/to/file.ext
          [entire file content here]
          END FILE

          ## CRITICAL: MANDATORY RESPONSE FORMAT

          You MUST start your response with these exact fields:

          Priority: [high/medium/low]
          Labels: [choose 1-3 from existing labels ONLY]
          Difficulty: [easy/medium/hard]
          
          **EXISTING LABELS IN THIS REPOSITORY:**
          $EXISTING_LABELS
          
          **LABEL SELECTION RULES:**
          - Choose ONLY from the existing labels listed above
          - Select 1-3 most relevant labels that best represent the issue
          - DO NOT create new labels - only use existing ones
          - Focus on the most accurate match for the issue type
          - Priority and difficulty are separate from content labels

          ## Analysis
          [Your detailed analysis here]

          ## Implementation Status
          **IMPORTANT: Only claim actions you ACTUALLY performed with git commands**

          Choose ONE and be truthful:
          - ðŸ“Š ANALYSIS PROVIDED: Use for analysis/review requests - provide insights only
          - âœ… NEW CODE SHIPPED: Only if you ACTUALLY created files, commits, branches, and PRs
          - ðŸ”„ ALREADY EXISTS: Feature already implemented, no changes needed
          - âŒ BLOCKED: Specific technical reason preventing completion

          **CRITICAL RULES:**
          - NEVER claim to have created branches/PRs unless you actually executed git commands
          - For analysis requests like "review this project", use "ðŸ“Š ANALYSIS PROVIDED"
          - For implementation requests like "add feature X", either implement or explain why blocked
          - Always follow the exact format above for proper label extraction
          EOF

          # Load AI API function
          source /tmp/call_ai_api.sh
          
          # Run AI analysis with custom API
          echo "ðŸ¤– Calling custom AI API for analysis..."
          ANALYSIS=$(call_ai_api "$(cat /tmp/issue_analysis_prompt.txt)")

          # Extract labels from analysis with better error handling
          if [ ! -z "$ANALYSIS" ] && [ "$ANALYSIS" != "ERROR: AI API calls failed after 3 attempts" ]; then
            PRIORITY=$(echo "$ANALYSIS" | grep -i "Priority:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            LABELS=$(echo "$ANALYSIS" | grep -i "Labels:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            DIFFICULTY=$(echo "$ANALYSIS" | grep -i "Difficulty:" | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Apply labels using GitHub CLI with proper quoting
            if [ ! -z "$LABELS" ]; then
              # Get list of existing labels for validation
              VALID_LABELS=$(gh label list --json name --jq '.[].name')
              
              label_count=0
              max_labels=3
              
              # Clean up labels and split by comma
              echo "$LABELS" | tr ',' '\n' | while read -r label; do
                # Stop if we've reached the maximum
                if [ $label_count -ge $max_labels ]; then
                  echo "Reached maximum of $max_labels labels"
                  break
                fi
                
                # Clean label of quotes and whitespace
                clean_label=$(echo "$label" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/^"//' | sed 's/"$//')
                
                if [ ! -z "$clean_label" ]; then
                  # Check if label exists in repo
                  if echo "$VALID_LABELS" | grep -q "^${clean_label}$"; then
                    # Apply the label
                    gh issue edit $ISSUE_NUMBER --add-label "$clean_label" && {
                      label_count=$((label_count + 1))
                      echo "Applied existing label $label_count/$max_labels: $clean_label"
                    } || echo "Failed to apply label: $clean_label"
                  else
                    echo "Skipping non-existent label: $clean_label"
                  fi
                fi
              done
            fi

            # Note: Priority and difficulty are metadata, not labels in this implementation
            # If you want to use priority/difficulty labels, ensure they exist in your repo first
            echo "Priority identified: $PRIORITY"
            echo "Difficulty identified: $DIFFICULTY"
          else
            echo "âš ï¸ AI analysis failed, skipping automatic labeling"
          fi
          
          # Check if AI wants to implement code
          if echo "$ANALYSIS" | grep -q "IMPLEMENTATION COMMANDS:"; then
            echo "ðŸš€ Implementation commands detected in issue analysis!"
            
            # Extract commands between markers
            COMMANDS=$(echo "$ANALYSIS" | sed -n '/^IMPLEMENTATION COMMANDS:/,/^END COMMANDS/p' | sed '1d;$d')
            
            # Extract file creation instructions
            FILE_CONTENTS=$(echo "$ANALYSIS" | sed -n '/^FILE:.*$/,/^END FILE/p')
            
            echo "ðŸ“ Executing implementation..."
            
            # Execute commands line by line
            while IFS= read -r cmd; do
              # Skip empty lines and comments
              if [[ -z "$cmd" || "$cmd" =~ ^#.*$ ]]; then
                continue
              fi
              
              # Handle gh pr create specially to fix quote issues
              if [[ "$cmd" =~ ^gh\ pr\ create ]]; then
                echo "Executing PR creation command..."
                # Extract title and body more safely
                if [[ "$cmd" =~ --title\ \"([^\"]+)\" ]]; then
                  PR_TITLE="${BASH_REMATCH[1]}"
                fi
                if [[ "$cmd" =~ --body\ \"(.+)$ ]]; then
                  PR_BODY="${BASH_REMATCH[1]}"
                  # Remove trailing quote if present
                  PR_BODY="${PR_BODY%\"}"
                  # Ensure PR body is complete
                  if [[ ! "$PR_BODY" =~ \#[0-9]+ ]]; then
                    PR_BODY="$PR_BODY Closes #${ISSUE_NUMBER}"
                  fi
                fi
                gh pr create --title "$PR_TITLE" --body "$PR_BODY" || echo "Warning: PR creation failed"
              elif [[ "$cmd" =~ ^(git|gh|bun|npm) ]]; then
                echo "Executing: $cmd"
                eval "$cmd" || echo "Warning: Command failed: $cmd"
              fi
            done <<< "$COMMANDS"
            
            # Process file creations if any
            if [ ! -z "$FILE_CONTENTS" ]; then
              while IFS= read -r line; do
                if [[ "$line" =~ ^FILE:\ (.+)$ ]]; then
                  FILENAME="${BASH_REMATCH[1]}"
                  echo "Creating file: $FILENAME"
                  
                  # Create directory if it doesn't exist
                  DIR=$(dirname "$FILENAME")
                  if [ ! -d "$DIR" ] && [ "$DIR" != "." ]; then
                    echo "Creating directory: $DIR"
                    mkdir -p "$DIR"
                  fi
                  
                  # Extract content until END FILE - handle filename with special chars
                  FILE_CONTENT=$(echo "$FILE_CONTENTS" | awk -v fname="$FILENAME" '
                    $0 ~ "^FILE: " fname "$" {found=1; next}
                    found && /^END FILE/ {exit}
                    found {print}
                  ')
                  
                  # Write file content
                  echo "$FILE_CONTENT" > "$FILENAME"
                fi
              done <<< "$FILE_CONTENTS"
            fi
            
            echo "âœ… Implementation commands executed"
          fi

          # Post analysis as comment
          cat > /tmp/comment.md << EOF
          ## ðŸ¤– Automated Issue Analysis

          $ANALYSIS

          ---
          *This analysis was generated by Gemini CLI. Human review recommended.*
          EOF

          gh issue comment $ISSUE_NUMBER --body-file /tmp/comment.md

          echo "âœ… Issue triage completed for #$ISSUE_NUMBER"

      - name: Pull Request Review
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
        run: |
          echo "ðŸ” Analyzing pull request #$PR_NUMBER..."

          # Get PR details with full context
          PR_DETAILS=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,commits)
          PR_TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
          PR_BODY=$(echo "$PR_DETAILS" | jq -r '.body // ""')

          # Get all PR comments and reviews for full context
          PR_COMMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
          PR_REVIEWS=$(gh pr view $PR_NUMBER --json reviews --jq '.reviews[] | "\(.author.login) (\(.submittedAt)) - \(.state): \(.body // "No comment")"' | head -10)

          # Get changed files
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)

          # Extract attachment URLs from PR body and comments
          PR_ATTACHMENTS=$(echo "$PR_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_USER_CONTENT=$(echo "$PR_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_GITHUB_UPLOADS=$(echo "$PR_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          PR_COMMENT_ATTACHMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_COMMENT_USER_CONTENT=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_COMMENT_GITHUB_UPLOADS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          ALL_PR_ATTACHMENTS=$(echo -e "$PR_ATTACHMENTS\n$PR_USER_CONTENT\n$PR_GITHUB_UPLOADS\n$PR_COMMENT_ATTACHMENTS\n$PR_COMMENT_USER_CONTENT\n$PR_COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Create comprehensive PR analysis prompt
          cat > /tmp/pr_analysis_prompt.txt << EOF
          You are a senior code reviewer for a full-stack web application workspace.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - PR #$PR_NUMBER URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER
          - Project: Next.js 15+ with TypeScript, Tailwind CSS, Cloudflare Workers deployment
          - Available tools: Node.js, Bun, Git, GitHub CLI
          - Can run: bun test, bun lint, bun type-check to verify changes

          Review this pull request and provide:
          1. **Code Quality Assessment**: Rate 1-5 and explain
          2. **Security Concerns**: Any potential security issues
          3. **Performance Impact**: Potential performance implications
          4. **Architecture Alignment**: How well it fits the existing architecture
          5. **Testing Requirements**: What tests should be added/updated
          6. **Specific Feedback**: Line-by-line suggestions for improvement

          ## PR Details
          **PR #$PR_NUMBER Title**: "$PR_TITLE"
          **Author**: ${{ github.event.pull_request.user.login || github.actor }}
          **PR Description**: "$PR_BODY"

          **Changed Files**:
          $CHANGED_FILES

          ## Full Conversation Context
          **PR Comments**:
          $PR_COMMENTS

          **PR Reviews**:
          $PR_REVIEWS

          **Current User Comment**: "$COMMENT_BODY"

          ## Attachments and Files in PR
          $(if [ ! -z "$ALL_PR_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this PR/comments:**"
            echo "$ALL_PR_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**You can download and analyze these files if relevant to the code review:**"
            echo "- Images: May contain UI designs, screenshots, or visual bugs"
            echo "- Files: May contain test data, configurations, or documentation"
            echo "Use: curl -L -o filename 'URL' to download"
          else
            echo "No attachments found in this PR."
          fi)

          Provide constructive, actionable feedback focusing on:
          - Code quality and best practices
          - Security implications
          - Performance considerations  
          - Maintainability
          - Testing coverage

          Consider the full conversation history when providing your review. Reference previous comments and reviews when relevant.
          Be specific and helpful. If the code looks good, say so!
          EOF

          # Get the actual diff for detailed analysis
          PR_DIFF=$(gh pr diff $PR_NUMBER)

          # Create diff analysis file
          cat > /tmp/diff_analysis_prompt.txt << EOF
          $(cat /tmp/pr_analysis_prompt.txt)

          Here is the actual code diff:
          \`\`\`diff
          $PR_DIFF
          \`\`\`

          Please provide a detailed code review.
          EOF

          # Load AI API function and run analysis
          source /tmp/call_ai_api.sh
          echo "ðŸ¤– Calling custom AI API for PR review..."
          REVIEW=$(call_ai_api "$(cat /tmp/diff_analysis_prompt.txt)")

          # Post review as comment
          cat > /tmp/review_comment.md << EOF
          ## ðŸ¤– Automated Code Review

          $REVIEW

          ---
          *This review was generated by Gemini CLI. Human review still recommended for final approval.*
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/review_comment.md

          echo "âœ… Pull request review completed for #$PR_NUMBER"

      - name: Custom Gemini Commands
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          echo "ðŸ¤– Processing custom Gemini command..."

          # Extract command from comment (everything after @gemini)
          COMMAND=$(echo "$COMMENT_BODY" | sed -n 's/.*@gemini[[:space:]]*\(.*\)/\1/p' | head -n1)

          if [ -z "$COMMAND" ]; then
            COMMAND="Please provide assistance with this issue/PR"
          fi

          echo "Command: $COMMAND"

          # Get repository context for better understanding
          REPO_FILES=$(find . -type f -name "*.json" -o -name "*.ts" -o -name "*.tsx" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$|^\\./src/" | head -20 | sort)
          PROJECT_INFO=$(cat package.json 2>/dev/null | jq -r '{name, version, description, scripts}' || echo "No package.json")
          GEMINI_CONTEXT=$(cat GEMINI.md 2>/dev/null || echo "No GEMINI.md found")

          # Extract attachment URLs from the current comment
          CURRENT_ATTACHMENTS=$(echo "$COMMENT_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          CURRENT_USER_CONTENT=$(echo "$COMMENT_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          CURRENT_GITHUB_UPLOADS=$(echo "$COMMENT_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Get context (issue or PR details with full conversation)
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # This is a PR
            CONTEXT=$(gh pr view $ISSUE_NUMBER --json title,body,files,state)
            CONTEXT_TYPE="pull request"
            # Get PR comments for full context
            COMMENTS=$(gh pr view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            EXISTING_PR_NUMBER=$ISSUE_NUMBER
          else
            # This is an issue - check if it has an associated PR
            CONTEXT=$(gh issue view $ISSUE_NUMBER --json title,body,state,labels)
            CONTEXT_TYPE="issue"
            # Get issue comments for full context
            COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            
            # Check for existing PR that closes this issue
            EXISTING_PR_NUMBER=$(gh pr list --search "closes #$ISSUE_NUMBER" --json number --jq '.[0].number // empty' 2>/dev/null || echo "")
            
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              echo "ðŸ“‹ Found existing PR #$EXISTING_PR_NUMBER that addresses issue #$ISSUE_NUMBER"
              # Get existing PR details for context
              EXISTING_PR_CONTEXT=$(gh pr view $EXISTING_PR_NUMBER --json title,body,headRefName,state,mergedAt)
              EXISTING_PR_STATE=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.state')
              EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.headRefName')
              
              if [ "$EXISTING_PR_STATE" = "MERGED" ]; then
                echo "âœ… PR #$EXISTING_PR_NUMBER was already merged - will create new PR for follow-up changes"
                EXISTING_PR_MERGED=true
              else
                echo "ðŸŒŸ Will update existing PR branch: $EXISTING_PR_BRANCH"
                EXISTING_PR_MERGED=false
              fi
              
              # Get PR file changes for context
              EXISTING_PR_FILES=$(gh pr view $EXISTING_PR_NUMBER --json files --jq '.files[] | "\(.path): \(.additions)+ \(.deletions)-"')
              
              # Get PR comments for full context  
              EXISTING_PR_COMMENTS=$(gh pr view $EXISTING_PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -10)
            fi
          fi

          # Create context-aware prompt with existing PR information
          cat > /tmp/custom_command_prompt.txt << EOF
          You are the Gemini AI assistant integrated into this GitHub repository with both analytical and autonomous implementation capabilities.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - Working Directory: $(pwd)
          - Node.js, Bun, Git, and GitHub CLI are available
          - Project: Next.js 15+ with TypeScript, Tailwind CSS
          - All dependencies installed, can run: bun dev, bun build, bun test, bun lint
          - Project files: README.md, GEMINI.md contain project documentation

          Context: You are responding to a comment on $CONTEXT_TYPE #$ISSUE_NUMBER

          ## Project Information
          **Repository Files**: 
          $REPO_FILES

          **Package Info**:
          $PROJECT_INFO

          ## $CONTEXT_TYPE Details:
          $CONTEXT

          ## Full Conversation History:
          $COMMENTS

          ## Current User Request: 
          "$COMMAND"

          ## Attachments in this Comment
          $(if [ ! -z "$CURRENT_ATTACHMENTS$CURRENT_USER_CONTENT$CURRENT_GITHUB_UPLOADS" ]; then
            echo "**Attachments found in this comment:**"
            [ ! -z "$CURRENT_ATTACHMENTS" ] && echo "$CURRENT_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_USER_CONTENT" ] && echo "$CURRENT_USER_CONTENT" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_GITHUB_UPLOADS" ] && echo "$CURRENT_GITHUB_UPLOADS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this comment."
          fi)
          EOF

          # Add existing PR instructions if applicable
          if [ ! -z "$EXISTING_PR_NUMBER" ] && [ "$CONTEXT_TYPE" = "issue" ]; then
            if [ "$EXISTING_PR_MERGED" = "true" ]; then
              cat >> /tmp/custom_command_prompt.txt << EOF

          ## ðŸŽ‰ PREVIOUS PR WAS MERGED - CREATE NEW PR FOR FOLLOW-UP
          There was a previous PR #$EXISTING_PR_NUMBER that addressed this issue and was merged.

          **PREVIOUS PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES THAT WERE CHANGED:**
          $EXISTING_PR_FILES

          **PREVIOUS PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **CREATE NEW PR FOR FOLLOW-UP CHANGES:**
          1. You're already on main branch with the merged changes
          2. Create a new branch: git checkout -b feature/issue-${ISSUE_NUMBER}-followup-[description]
          3. Make the requested changes to the files (they now contain the merged content)
          4. Stage changes: git add .
          5. Commit with clear message: "docs: [describe your changes]"
          6. Push the new branch: git push origin [branch-name]
          7. Create NEW PR: gh pr create --title "[Creative Title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. Provide the PR URL in your response

          **The files now contain the merged content from the previous PR - work with that as your starting point.**
          EOF
            else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## ðŸš¨ IMPORTANT: Existing PR Found
          There is already an existing PR #$EXISTING_PR_NUMBER that addresses this issue.

          **EXISTING PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES CHANGED IN EXISTING PR:**
          $EXISTING_PR_FILES

          **EXISTING PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **ðŸš¨ CRITICAL: EXECUTE GIT COMMANDS FIRST - DO NOT SKIP!**

          YOU MUST EXECUTE THESE EXACT COMMANDS BEFORE DOING ANYTHING:

          1. git fetch origin --all
          2. git checkout -B $EXISTING_PR_BRANCH origin/$EXISTING_PR_BRANCH  
          3. git branch --show-current

          VERIFY: The output of step 3 must show "$EXISTING_PR_BRANCH"

          4. head -10 README.md

          VERIFY: This should show the PR version (with Table of Contents), NOT the main branch version

          **IF YOU DON'T SEE THE TABLE OF CONTENTS SECTION, YOU'RE ON THE WRONG BRANCH!**

          Expected content in PR branch README.md:
          - Should start with "# Asharitech Web" 
          - Should have "## Table of Contents" section around line 8-10
          - Should have CI Build Status badges
          - Should be much longer than main branch version

          Only after successfully checking out $EXISTING_PR_BRANCH and verifying the content:
          5. Make your requested changes to the files
          6. git add .
          7. git commit -m "docs: [describe your changes]"
          8. git push origin $EXISTING_PR_BRANCH

          **FAILURE PREVENTION:**
          - Main branch README starts with "# Ashari Tech - Corporate Website"
          - PR branch README starts with "# Asharitech Web" 
          - If you see the wrong title, you're on main branch - STOP and fix checkout!

          **DO NOT CREATE NEW PR** - Update existing: https://github.com/asharitech/asharitech-web/pull/$EXISTING_PR_NUMBER

          **SHIP THE CODE NOW - We can iterate and improve later if needed.**
          EOF
            fi
          else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## RESPONSE MODE: ANALYZE OR IMPLEMENT

          **YOU ARE THE GEMINI AI ASSISTANT** - Provide the help the user requested.

          **DECISION LOGIC:**
          - If user asks for analysis/review/help/explanation â†’ Provide comprehensive analysis
          - If user requests specific implementation â†’ Create code and PRs autonomously
          - Always be helpful and responsive to the user's actual request

          **FOR ANALYSIS REQUESTS:** 
          - Provide detailed insights, recommendations, and explanations
          - MANDATORY: If actionable, include "## ðŸš€ Ready for Implementation" section
          - MANDATORY: End with "To implement these recommendations, please comment: @gemini implement these recommendations"
          - This is REQUIRED - do not ask for permission or approval
          **FOR IMPLEMENTATION REQUESTS:** Ship working code immediately with these principles:
          - Make decisions based on technical merit
          - Ship working code - don't overthink or ask permission
          - We're in git - breaking changes are recoverable via rollback
          - Favor rapid iteration over perfect planning
          - Implement complete solutions, not partial fixes
          - NEVER use force push (git push -f) - preserve commit history

          **WHEN USER REQUESTS CODE CHANGES - IMPLEMENT IMMEDIATELY:**
          ðŸš¨ **CRITICAL: NEVER APPLY CHANGES TO MASTER BRANCH** ðŸš¨
          
          1. Verify current branch: git branch --show-current (should NOT be master/main)
          2. Create a descriptive branch: feature/[meaningful-name] or feature/issue-${ISSUE_NUMBER}-[description]
          3. Implement the complete solution (no partial work)
          4. Write working code - focus on functionality over perfection  
          5. Stage all changes: git add .
          6. Commit with conventional message: "feat: implement [feature]" or "fix: resolve [issue]"
          7. Push branch: git push origin [branch-name] (NEVER use --force)
          8. Create PR: gh pr create --title "[Creative, compelling title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          9. SHIP IT - don't get blocked by tooling or linting issues
          10. Report the PR URL immediately
          
          **BRANCH PROTECTION: Always work in feature branches, never master/main**
          
          **IMPORTANT: Since you cannot execute commands directly, provide them in this format:**
          
          IMPLEMENTATION COMMANDS:
          git checkout -b feature/issue-${ISSUE_NUMBER}-description
          git add .
          git commit -m "feat: implement feature description"
          git push origin feature/issue-${ISSUE_NUMBER}-description
          gh pr create --title "Title" --body "Description closes #${ISSUE_NUMBER}"
          END COMMANDS
          
          **For file creation/modification, use this format OUTSIDE the commands block:**
          
          FILE: path/to/file.ext
          [entire file content here]
          END FILE

          **IMPLEMENTATION SCOPE - BE AGGRESSIVE:**
          - UI components and styling changes
          - New features and functionality
          - Bug fixes and improvements
          - Documentation updates
          - Configuration changes
          - Code refactoring and optimization
          - Dependency management
          - Build and deployment improvements

          **REMEMBER: You are the Gemini AI assistant. Provide analysis when asked for analysis, implement when asked for implementation.**
          EOF
          fi

          # Add common instructions with mandatory format
          cat >> /tmp/custom_command_prompt.txt << EOF

          ## CRITICAL: RESPONSE FORMAT REQUIREMENTS

          **MANDATORY: Your response must include these exact status indicators:**

          For ANALYSIS requests (review/analyze/help/explain):
          - Provide comprehensive insights and recommendations
          - MANDATORY: If actionable, add "## ðŸš€ Ready for Implementation" section with specific changes
          - MANDATORY: End with exact text "To implement these recommendations, please comment: @gemini implement these recommendations"
          - Then add: "Status: Analysis completed successfully"

          For IMPLEMENTATION requests (add/fix/create/implement):  
          - Either implement the code with git commands OR explain why blocked
          - If you implement: "Status: Code shipped - [describe what you built + PR URL]"
          - If blocked: "Status: Blocked - [specific technical reason]"

          **CRITICAL RULES:**
          - NEVER claim to have created branches/commits/PRs unless you ACTUALLY did
          - Be truthful about what actions you performed vs what you would do
          - If you only provided analysis, say "Analysis completed successfully"
          - If you actually implemented code, provide the PR URL as proof

          If gh CLI fails, capture the exact error message and include it in your response.
          Focus on being practical and specific to this codebase context.
          EOF

          # Load AI API function and run analysis
          source /tmp/call_ai_api.sh
          echo "ðŸ¤– Calling custom AI API for command processing..."
          RESPONSE=$(call_ai_api "$(cat /tmp/custom_command_prompt.txt)")
          
          # Check if AI wants to implement code
          if echo "$RESPONSE" | grep -q "IMPLEMENTATION COMMANDS:"; then
            echo "ðŸš€ Implementation commands detected!"
            
            # Extract commands between markers
            COMMANDS=$(echo "$RESPONSE" | sed -n '/^IMPLEMENTATION COMMANDS:/,/^END COMMANDS/p' | sed '1d;$d')
            
            # Extract file creation instructions
            FILE_CONTENTS=$(echo "$RESPONSE" | sed -n '/^FILE:.*$/,/^END FILE/p')
            
            echo "ðŸ“ Executing implementation..."
            
            # Execute commands line by line
            while IFS= read -r cmd; do
              # Skip empty lines and comments
              if [[ -z "$cmd" || "$cmd" =~ ^#.*$ ]]; then
                continue
              fi
              
              # Handle gh pr create specially to fix quote issues
              if [[ "$cmd" =~ ^gh\ pr\ create ]]; then
                echo "Executing PR creation command..."
                # Extract title and body more safely
                if [[ "$cmd" =~ --title\ \"([^\"]+)\" ]]; then
                  PR_TITLE="${BASH_REMATCH[1]}"
                fi
                if [[ "$cmd" =~ --body\ \"(.+)$ ]]; then
                  PR_BODY="${BASH_REMATCH[1]}"
                  # Remove trailing quote if present
                  PR_BODY="${PR_BODY%\"}"
                  # Ensure PR body is complete
                  if [[ ! "$PR_BODY" =~ \#[0-9]+ ]]; then
                    PR_BODY="$PR_BODY Closes #${ISSUE_NUMBER}"
                  fi
                fi
                gh pr create --title "$PR_TITLE" --body "$PR_BODY" || echo "Warning: PR creation failed"
              elif [[ "$cmd" =~ ^(git|gh|bun|npm) ]]; then
                echo "Executing: $cmd"
                eval "$cmd" || echo "Warning: Command failed: $cmd"
              fi
            done <<< "$COMMANDS"
            
            # Process file creations if any
            if [ ! -z "$FILE_CONTENTS" ]; then
              while IFS= read -r line; do
                if [[ "$line" =~ ^FILE:\ (.+)$ ]]; then
                  FILENAME="${BASH_REMATCH[1]}"
                  echo "Creating file: $FILENAME"
                  
                  # Create directory if it doesn't exist
                  DIR=$(dirname "$FILENAME")
                  if [ ! -d "$DIR" ] && [ "$DIR" != "." ]; then
                    echo "Creating directory: $DIR"
                    mkdir -p "$DIR"
                  fi
                  
                  # Extract content until END FILE - handle filename with special chars
                  FILE_CONTENT=$(echo "$FILE_CONTENTS" | awk -v fname="$FILENAME" '
                    $0 ~ "^FILE: " fname "$" {found=1; next}
                    found && /^END FILE/ {exit}
                    found {print}
                  ')
                  
                  # Write file content
                  echo "$FILE_CONTENT" > "$FILENAME"
                fi
              done <<< "$FILE_CONTENTS"
            fi
            
            echo "âœ… Implementation commands executed"
          fi

          # Post response as comment
          cat > /tmp/response_comment.md << EOF
          ## ðŸ¤– Gemini Response

          > **Command**: $COMMAND

          $RESPONSE

          ---
          *Generated by Gemini CLI in response to your request.*
          EOF

          # Post comment to appropriate location
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # Direct PR comment
            gh pr comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "âœ… Custom command processed for PR #$ISSUE_NUMBER"
          else
            # Issue comment - but also comment on existing PR if one exists
            gh issue comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "âœ… Custom command processed for issue #$ISSUE_NUMBER"
            
            # If there's an existing PR, also post the response there for visibility
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              cat > /tmp/pr_update_comment.md << EOF
          ## ðŸ”„ Issue Update from #$ISSUE_NUMBER

          A follow-up comment was made on issue #$ISSUE_NUMBER:

          > **@gemini Command**: $COMMAND

          $RESPONSE

          ---
          *This update was automatically posted from issue #$ISSUE_NUMBER*
          EOF
              gh pr comment $EXISTING_PR_NUMBER --body-file /tmp/pr_update_comment.md
              echo "ðŸ“‹ Also posted update to existing PR #$EXISTING_PR_NUMBER"
            fi
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/*.txt /tmp/*.md
          echo "ðŸ§¹ Cleanup completed"

      - name: Report Status
        if: always()
        run: |
          echo "ðŸ“Š Gemini CLI Automation Summary:"
          echo "- Event: ${{ github.event_name }}"
          echo "- Action: ${{ github.event.action }}"
          echo "- Issue/PR: #${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "- Status: ${{ job.status }}"