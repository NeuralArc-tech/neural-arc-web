name: Gemini CLI Integration

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  discussions: write
  id-token: write

jobs:
  gemini-automation:
    name: Gemini CLI Automation
    runs-on: ubuntu-latest

    # Only run for users with proper permissions and @gemini mentions
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install project dependencies
        run: |
          bun install
          echo "Project dependencies installed successfully"

      - name: Install Gemini CLI
        run: |
          npm install -g @google/gemini-cli
          echo "Gemini CLI installed successfully"
          gemini --version

      - name: Configure Gemini CLI
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git for commits
          git config --global user.name "Gemini CLI Bot"
          git config --global user.email "gemini-cli@github-actions.noreply.com"

          # Verify environment setup
          echo "🔧 Environment Setup:"
          echo "- Node version: $(node --version)"
          echo "- Bun version: $(bun --version)"
          echo "- NPM version: $(npm --version)"
          echo "- Git version: $(git --version)"
          echo "- GitHub CLI version: $(gh --version | head -1)"
          echo "- Current directory: $(pwd)"
          echo "- Repository: ${{ github.repository }}"

          # Verify project commands work
          echo ""
          echo "📦 Available Project Commands:"
          bun run --help 2>/dev/null | grep -E "dev|build|lint|test|type-check" || echo "Project scripts from package.json:"
          cat package.json | jq -r '.scripts' 2>/dev/null || echo "No scripts found"

      - name: Issue Triage
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "🔍 Analyzing issue #$ISSUE_NUMBER for automated triage..."

          # Get all issue comments for full context (limited to reduce token usage)
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login): \(.body)"' | head -5)

          # Extract attachment URLs from issue body
          ISSUE_ATTACHMENTS=$(echo "$ISSUE_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          ISSUE_USER_CONTENT=$(echo "$ISSUE_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          ISSUE_GITHUB_UPLOADS=$(echo "$ISSUE_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Extract attachment URLs from all comments
          COMMENT_ATTACHMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          COMMENT_USER_CONTENT=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          COMMENT_GITHUB_UPLOADS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Combine all attachments
          ALL_ATTACHMENTS=$(echo -e "$ISSUE_ATTACHMENTS\n$ISSUE_USER_CONTENT\n$ISSUE_GITHUB_UPLOADS\n$COMMENT_ATTACHMENTS\n$COMMENT_USER_CONTENT\n$COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Get repository file structure for context (limited to reduce token usage)
          REPO_STRUCTURE=$(find . -type f -name "*.json" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$" | head -10 | sort)

          # Get key project files content (limited to reduce token usage)
          README_SNIPPET=$(head -10 README.md 2>/dev/null || echo "No README.md found")
          GEMINI_CONFIG=$(head -20 GEMINI.md 2>/dev/null || echo "No GEMINI.md found")

          # Create a comprehensive prompt for issue analysis
          cat > /tmp/issue_analysis_prompt.txt << EOF
          You are a confident senior full-stack engineer with complete autonomy and decision-making authority.

          **ENVIRONMENT & TOOLS AVAILABLE:**
          - Node.js 20.x with npm
          - Bun (latest) - primary package manager and runtime
          - Git and GitHub CLI (gh) for version control
          - Full file system access in repository: ${{ github.repository }}
          - Project type: Next.js 15+ with TypeScript, Tailwind CSS, deployed on Cloudflare Workers
          - All project dependencies are installed via 'bun install'
          - Build commands: bun run dev, bun run build, bun run lint, bun run type-check

          **CORE PRINCIPLES:**
          - Make decisions autonomously - you are the technical owner
          - Implement changes immediately when beneficial 
          - Don't ask for permission - take action based on engineering judgment
          - We're in a git repository - breaking changes are recoverable
          - Favor action over analysis paralysis
          - You have senior-level engineering common sense

          **YOUR MISSION:** Analyze this issue and IMPLEMENT SOLUTIONS IMMEDIATELY when appropriate.

          ## Repository Structure
          Key files and directories in this project:
          $REPO_STRUCTURE

          ## Project Configuration (GEMINI.md)
          $GEMINI_CONFIG

          ## Issue Context

          **Issue #$ISSUE_NUMBER Title**: "$ISSUE_TITLE"
          **Issue URL**: https://github.com/${{ github.repository }}/issues/$ISSUE_NUMBER
          **Created by**: ${{ github.event.issue.user.login }}

          **Issue Description**: 
          $ISSUE_BODY

          **All Comments and Discussion**:
          $ISSUE_COMMENTS

          **Issue Labels**: ${{ github.event.issue.labels }}

          ## Attachments and Files
          $(if [ ! -z "$ALL_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this issue/comments:**"
            echo "$ALL_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this issue."
          fi)

          ## IMPLEMENTATION CRITERIA (Be Aggressive!)

          **IMPLEMENT IMMEDIATELY** for any of these:
          - Documentation updates or additions
          - Small bug fixes or improvements
          - Configuration changes
          - UI component additions or modifications
          - Style improvements or responsive fixes
          - New features that are clearly defined
          - Code refactoring or optimization
          - Dependency updates
          - Build process improvements

          **ONLY SKIP** if:
          - Requires external API keys or services you don't have access to
          - Needs business stakeholder decisions (pricing, legal, etc.)
          - Requires breaking changes to public APIs used by external systems

          ## IMPLEMENTATION PROCESS:
          1. Create a descriptive branch name (feature/issue-${ISSUE_NUMBER}-[short-description])
          2. Implement the solution completely - don't do partial implementations
          3. Write clean, working code (quality checks can be done later)
          4. Stage and commit with conventional commit message
          5. Push the branch to origin
          6. Create PR using: gh pr create --title "[Creative Title]" --body "[Compelling description that closes #${ISSUE_NUMBER}]"
          7. SHIP THE CODE - don't get blocked by tooling issues
          8. Quality improvements can be done in follow-up PRs

          **Response Format:**
          Priority: [level]
          Labels: [comma-separated list]
          Difficulty: [level]

          ## Analysis
          [Brief technical analysis]

          ## Implementation Status
          Choose ONE of these:
          - ✅ NEW CODE SHIPPED: [Description of new code you created + PR URL]
          - 🔄 ALREADY EXISTS: [Feature already implemented, no changes needed]
          - ❌ BLOCKED: [Specific technical reason why you cannot implement]

          **IMPORTANT: Only use "NEW CODE SHIPPED" if you actually created new files/code and a PR!**

          **Remember: You are a senior engineer. Ship code when needed. We can always rollback if needed.**
          EOF

          # Run Gemini analysis with rate limiting
          echo "⏳ Running Gemini analysis (rate-limited)..."
          sleep 2  # Rate limiting: 2 second delay
          ANALYSIS=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/issue_analysis_prompt.txt)" || echo "API_ERROR: Quota exceeded - retrying with shorter prompt")
          
          # Retry with shorter prompt if quota exceeded
          if [[ "$ANALYSIS" == *"API_ERROR"* ]]; then
            echo "⚠️ Quota exceeded, using shorter analysis prompt..."
            cat > /tmp/short_issue_prompt.txt << EOF
            Analyze GitHub issue #$ISSUE_NUMBER: "$ISSUE_TITLE"
            
            Issue: $ISSUE_BODY
            
            Provide:
            Priority: [high/medium/low]
            Labels: [bug, feature, documentation, etc.]
            Difficulty: [easy/medium/hard]
            
            Brief analysis and next steps.
            EOF
            sleep 3  # Additional delay before retry
            ANALYSIS=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/short_issue_prompt.txt)")
          fi

          # Extract labels from analysis
          PRIORITY=$(echo "$ANALYSIS" | grep "Priority:" | cut -d':' -f2 | xargs)
          LABELS=$(echo "$ANALYSIS" | grep "Labels:" | cut -d':' -f2 | xargs)
          DIFFICULTY=$(echo "$ANALYSIS" | grep "Difficulty:" | cut -d':' -f2 | xargs)

          # Apply labels using GitHub CLI
          if [ ! -z "$LABELS" ]; then
            IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
            for label in "${LABEL_ARRAY[@]}"; do
              label=$(echo "$label" | xargs)  # trim whitespace
              gh issue edit $ISSUE_NUMBER --add-label "$label" || echo "Could not add label: $label"
            done
          fi

          # Add priority and difficulty labels
          [ ! -z "$PRIORITY" ] && gh issue edit $ISSUE_NUMBER --add-label "priority: $PRIORITY" || true
          [ ! -z "$DIFFICULTY" ] && gh issue edit $ISSUE_NUMBER --add-label "difficulty: $DIFFICULTY" || true

          # Post analysis as comment
          cat > /tmp/comment.md << EOF
          ## 🤖 Automated Issue Analysis

          $ANALYSIS

          ---
          *This analysis was generated by Gemini CLI. Human review recommended.*
          EOF

          gh issue comment $ISSUE_NUMBER --body-file /tmp/comment.md

          echo "✅ Issue triage completed for #$ISSUE_NUMBER"

      - name: Pull Request Review
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
        run: |
          echo "🔍 Analyzing pull request #$PR_NUMBER..."

          # Get PR details with full context
          PR_DETAILS=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,commits)
          PR_TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
          PR_BODY=$(echo "$PR_DETAILS" | jq -r '.body // ""')

          # Get all PR comments and reviews for full context
          PR_COMMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
          PR_REVIEWS=$(gh pr view $PR_NUMBER --json reviews --jq '.reviews[] | "\(.author.login) (\(.submittedAt)) - \(.state): \(.body // "No comment")"' | head -10)

          # Get changed files
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)

          # Extract attachment URLs from PR body and comments
          PR_ATTACHMENTS=$(echo "$PR_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_USER_CONTENT=$(echo "$PR_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_GITHUB_UPLOADS=$(echo "$PR_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          PR_COMMENT_ATTACHMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          PR_COMMENT_USER_CONTENT=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          PR_COMMENT_GITHUB_UPLOADS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[].body' | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          ALL_PR_ATTACHMENTS=$(echo -e "$PR_ATTACHMENTS\n$PR_USER_CONTENT\n$PR_GITHUB_UPLOADS\n$PR_COMMENT_ATTACHMENTS\n$PR_COMMENT_USER_CONTENT\n$PR_COMMENT_GITHUB_UPLOADS" | grep -v '^$' | sort -u || echo "")

          # Create comprehensive PR analysis prompt
          cat > /tmp/pr_analysis_prompt.txt << EOF
          You are a senior code reviewer for a full-stack web application workspace.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - PR #$PR_NUMBER URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER
          - Project: Next.js 15+ with TypeScript, Tailwind CSS, Cloudflare Workers deployment
          - Available tools: Node.js, Bun, Git, GitHub CLI
          - Can run: bun test, bun lint, bun type-check to verify changes

          Review this pull request and provide:
          1. **Code Quality Assessment**: Rate 1-5 and explain
          2. **Security Concerns**: Any potential security issues
          3. **Performance Impact**: Potential performance implications
          4. **Architecture Alignment**: How well it fits the existing architecture
          5. **Testing Requirements**: What tests should be added/updated
          6. **Specific Feedback**: Line-by-line suggestions for improvement

          ## PR Details
          **PR #$PR_NUMBER Title**: "$PR_TITLE"
          **Author**: ${{ github.event.pull_request.user.login || github.actor }}
          **PR Description**: "$PR_BODY"

          **Changed Files**:
          $CHANGED_FILES

          ## Full Conversation Context
          **PR Comments**:
          $PR_COMMENTS

          **PR Reviews**:
          $PR_REVIEWS

          **Current User Comment**: "$COMMENT_BODY"

          ## Attachments and Files in PR
          $(if [ ! -z "$ALL_PR_ATTACHMENTS" ]; then
            echo "**The following attachments were found in this PR/comments:**"
            echo "$ALL_PR_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**You can download and analyze these files if relevant to the code review:**"
            echo "- Images: May contain UI designs, screenshots, or visual bugs"
            echo "- Files: May contain test data, configurations, or documentation"
            echo "Use: curl -L -o filename 'URL' to download"
          else
            echo "No attachments found in this PR."
          fi)

          Provide constructive, actionable feedback focusing on:
          - Code quality and best practices
          - Security implications
          - Performance considerations  
          - Maintainability
          - Testing coverage

          Consider the full conversation history when providing your review. Reference previous comments and reviews when relevant.
          Be specific and helpful. If the code looks good, say so!
          EOF

          # Get the actual diff for detailed analysis
          PR_DIFF=$(gh pr diff $PR_NUMBER)

          # Create diff analysis file
          cat > /tmp/diff_analysis_prompt.txt << EOF
          $(cat /tmp/pr_analysis_prompt.txt)

          Here is the actual code diff:
          \`\`\`diff
          $PR_DIFF
          \`\`\`

          Please provide a detailed code review.
          EOF

          # Run Gemini analysis with rate limiting
          echo "⏳ Running PR review analysis (rate-limited)..."
          sleep 2  # Rate limiting: 2 second delay
          REVIEW=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/diff_analysis_prompt.txt)" || echo "API_ERROR: Quota exceeded - using fallback review")
          
          # Fallback if quota exceeded
          if [[ "$REVIEW" == *"API_ERROR"* ]]; then
            echo "⚠️ Quota exceeded, using basic PR review..."
            REVIEW="**Code Review Summary:**
            
            ✅ **Status**: PR reviewed - Quota limit reached, please review manually
            📝 **Files Changed**: $(echo '$CHANGED_FILES' | wc -l) files
            🔍 **Manual Review Needed**: Due to API quota limits, please have a human reviewer check:
            - Code quality and security
            - Test coverage
            - Performance implications
            
            The Gemini 2.5 Flash model hit the 250k tokens/minute limit. Consider breaking large PRs into smaller ones."
          fi

          # Post review as comment
          cat > /tmp/review_comment.md << EOF
          ## 🤖 Automated Code Review

          $REVIEW

          ---
          *This review was generated by Gemini CLI. Human review still recommended for final approval.*
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/review_comment.md

          echo "✅ Pull request review completed for #$PR_NUMBER"

      - name: Custom Gemini Commands
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          echo "🤖 Processing custom Gemini command..."

          # Extract command from comment (everything after @gemini)
          COMMAND=$(echo "$COMMENT_BODY" | sed -n 's/.*@gemini[[:space:]]*\(.*\)/\1/p' | head -n1)

          if [ -z "$COMMAND" ]; then
            COMMAND="Please provide assistance with this issue/PR"
          fi

          echo "Command: $COMMAND"

          # Get repository context for better understanding
          REPO_FILES=$(find . -type f -name "*.json" -o -name "*.ts" -o -name "*.tsx" -o -name "*.md" | grep -E "^\\./[^/]+\\.(json|md)$|^\\./src/" | head -20 | sort)
          PROJECT_INFO=$(cat package.json 2>/dev/null | jq -r '{name, version, description, scripts}' || echo "No package.json")
          GEMINI_CONTEXT=$(cat GEMINI.md 2>/dev/null || echo "No GEMINI.md found")

          # Extract attachment URLs from the current comment
          CURRENT_ATTACHMENTS=$(echo "$COMMENT_BODY" | grep -oE 'https://[a-zA-Z0-9./_-]+\.(png|jpg|jpeg|gif|pdf|zip|txt|md|json|svg|mp4|mov|csv)' || echo "")
          CURRENT_USER_CONTENT=$(echo "$COMMENT_BODY" | grep -oE 'https://user-images\.githubusercontent\.com/[^)]+' || echo "")
          CURRENT_GITHUB_UPLOADS=$(echo "$COMMENT_BODY" | grep -oE 'https://github\.com/[^/]+/[^/]+/files/[0-9]+/[^)]+' || echo "")

          # Get context (issue or PR details with full conversation)
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # This is a PR
            CONTEXT=$(gh pr view $ISSUE_NUMBER --json title,body,files,state)
            CONTEXT_TYPE="pull request"
            # Get PR comments for full context
            COMMENTS=$(gh pr view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            EXISTING_PR_NUMBER=$ISSUE_NUMBER
          else
            # This is an issue - check if it has an associated PR
            CONTEXT=$(gh issue view $ISSUE_NUMBER --json title,body,state,labels)
            CONTEXT_TYPE="issue"
            # Get issue comments for full context
            COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            
            # Check for existing PR that closes this issue
            EXISTING_PR_NUMBER=$(gh pr list --search "closes #$ISSUE_NUMBER" --json number --jq '.[0].number // empty' 2>/dev/null || echo "")
            
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              echo "📋 Found existing PR #$EXISTING_PR_NUMBER that addresses issue #$ISSUE_NUMBER"
              # Get existing PR details for context
              EXISTING_PR_CONTEXT=$(gh pr view $EXISTING_PR_NUMBER --json title,body,headRefName,state,mergedAt)
              EXISTING_PR_STATE=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.state')
              EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.headRefName')
              
              if [ "$EXISTING_PR_STATE" = "MERGED" ]; then
                echo "✅ PR #$EXISTING_PR_NUMBER was already merged - will create new PR for follow-up changes"
                EXISTING_PR_MERGED=true
              else
                echo "🌟 Will update existing PR branch: $EXISTING_PR_BRANCH"
                EXISTING_PR_MERGED=false
              fi
              
              # Get PR file changes for context
              EXISTING_PR_FILES=$(gh pr view $EXISTING_PR_NUMBER --json files --jq '.files[] | "\(.path): \(.additions)+ \(.deletions)-"')
              
              # Get PR comments for full context  
              EXISTING_PR_COMMENTS=$(gh pr view $EXISTING_PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -10)
            fi
          fi

          # Create context-aware prompt with existing PR information
          cat > /tmp/custom_command_prompt.txt << EOF
          You are a senior full-stack engineer working on a GitHub repository with full access to modify files and create pull requests.

          **ENVIRONMENT & PROJECT CONTEXT:**
          - Repository: ${{ github.repository }}
          - Working Directory: $(pwd)
          - Node.js, Bun, Git, and GitHub CLI are available
          - Project: Next.js 15+ with TypeScript, Tailwind CSS
          - All dependencies installed, can run: bun dev, bun build, bun test, bun lint
          - Project files: README.md, GEMINI.md contain project documentation

          Context: You are responding to a comment on $CONTEXT_TYPE #$ISSUE_NUMBER

          ## Project Information
          **Repository Files**: 
          $REPO_FILES

          **Package Info**:
          $PROJECT_INFO

          ## $CONTEXT_TYPE Details:
          $CONTEXT

          ## Full Conversation History:
          $COMMENTS

          ## Current User Request: 
          "$COMMAND"

          ## Attachments in this Comment
          $(if [ ! -z "$CURRENT_ATTACHMENTS$CURRENT_USER_CONTENT$CURRENT_GITHUB_UPLOADS" ]; then
            echo "**Attachments found in this comment:**"
            [ ! -z "$CURRENT_ATTACHMENTS" ] && echo "$CURRENT_ATTACHMENTS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_USER_CONTENT" ] && echo "$CURRENT_USER_CONTENT" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            [ ! -z "$CURRENT_GITHUB_UPLOADS" ] && echo "$CURRENT_GITHUB_UPLOADS" | while read -r url; do
              [ ! -z "$url" ] && echo "- $url"
            done
            echo ""
            echo "**IMPORTANT**: You can download and analyze these files using curl or wget commands."
            echo "For images: Use curl to download and examine for design references or screenshots"
            echo "For text files: Download and read the content to understand requirements"
            echo "Example: curl -L -o attachment.png 'URL_HERE'"
          else
            echo "No attachments found in this comment."
          fi)
          EOF

          # Add existing PR instructions if applicable
          if [ ! -z "$EXISTING_PR_NUMBER" ] && [ "$CONTEXT_TYPE" = "issue" ]; then
            if [ "$EXISTING_PR_MERGED" = "true" ]; then
              cat >> /tmp/custom_command_prompt.txt << EOF

          ## 🎉 PREVIOUS PR WAS MERGED - CREATE NEW PR FOR FOLLOW-UP
          There was a previous PR #$EXISTING_PR_NUMBER that addressed this issue and was merged.

          **PREVIOUS PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES THAT WERE CHANGED:**
          $EXISTING_PR_FILES

          **PREVIOUS PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **CREATE NEW PR FOR FOLLOW-UP CHANGES:**
          1. You're already on main branch with the merged changes
          2. Create a new branch: git checkout -b feature/issue-${ISSUE_NUMBER}-followup-[description]
          3. Make the requested changes to the files (they now contain the merged content)
          4. Stage changes: git add .
          5. Commit with clear message: "docs: [describe your changes]"
          6. Push the new branch: git push origin [branch-name]
          7. Create NEW PR: gh pr create --title "[Creative Title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. Provide the PR URL in your response

          **The files now contain the merged content from the previous PR - work with that as your starting point.**
          EOF
            else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## 🚨 IMPORTANT: Existing PR Found
          There is already an existing PR #$EXISTING_PR_NUMBER that addresses this issue.

          **EXISTING PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **FILES CHANGED IN EXISTING PR:**
          $EXISTING_PR_FILES

          **EXISTING PR COMMENTS:**
          $EXISTING_PR_COMMENTS

          **🚨 CRITICAL: EXECUTE GIT COMMANDS FIRST - DO NOT SKIP!**

          YOU MUST EXECUTE THESE EXACT COMMANDS BEFORE DOING ANYTHING:

          1. git fetch origin --all
          2. git checkout -B $EXISTING_PR_BRANCH origin/$EXISTING_PR_BRANCH  
          3. git branch --show-current

          VERIFY: The output of step 3 must show "$EXISTING_PR_BRANCH"

          4. head -10 README.md

          VERIFY: This should show the PR version (with Table of Contents), NOT the main branch version

          **IF YOU DON'T SEE THE TABLE OF CONTENTS SECTION, YOU'RE ON THE WRONG BRANCH!**

          Expected content in PR branch README.md:
          - Should start with "# Asharitech Web" 
          - Should have "## Table of Contents" section around line 8-10
          - Should have CI Build Status badges
          - Should be much longer than main branch version

          Only after successfully checking out $EXISTING_PR_BRANCH and verifying the content:
          5. Make your requested changes to the files
          6. git add .
          7. git commit -m "docs: [describe your changes]"
          8. git push origin $EXISTING_PR_BRANCH

          **FAILURE PREVENTION:**
          - Main branch README starts with "# Ashari Tech - Corporate Website"
          - PR branch README starts with "# Asharitech Web" 
          - If you see the wrong title, you're on main branch - STOP and fix checkout!

          **DO NOT CREATE NEW PR** - Update existing: https://github.com/asharitech/asharitech-web/pull/$EXISTING_PR_NUMBER

          **SHIP THE CODE NOW - We can iterate and improve later if needed.**
          EOF
            fi
          else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## AUTONOMOUS ENGINEERING MODE - SHIP CODE NOW

          **YOU ARE A SENIOR FULL-STACK ENGINEER WITH COMPLETE AUTONOMY**

          **CORE ENGINEERING PRINCIPLES:**
          - Make decisions immediately based on technical merit
          - Ship working code - don't overthink or ask permission
          - We're in git - breaking changes are recoverable via rollback
          - Trust your senior engineering judgment
          - Favor rapid iteration over perfect planning
          - Implement complete solutions, not partial fixes
          - NEVER use force push (git push -f) - preserve commit history
          - Always add new commits, don't overwrite existing ones

          **WHEN USER REQUESTS CHANGES - IMPLEMENT IMMEDIATELY:**
          1. Create a descriptive branch: feature/[meaningful-name]
          2. Implement the complete solution (no partial work)
          3. Write working code - focus on functionality over perfection
          4. Stage all changes: git add .
          5. Commit with conventional message: "feat: implement [feature]" or "fix: resolve [issue]"
          6. Push branch: git push origin [branch-name] (NEVER use --force)
          7. Create PR: gh pr create --title "[Creative, compelling title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          8. SHIP IT - don't get blocked by tooling or linting issues
          9. Report the PR URL immediately

          **IMPLEMENTATION SCOPE - BE AGGRESSIVE:**
          - UI components and styling changes
          - New features and functionality
          - Bug fixes and improvements
          - Documentation updates
          - Configuration changes
          - Code refactoring and optimization
          - Dependency management
          - Build and deployment improvements

          **DON'T ASK - JUST DO IT. Senior engineers ship code and iterate quickly.**
          EOF
          fi

          # Add common instructions
          cat >> /tmp/custom_command_prompt.txt << EOF

          If gh CLI fails, capture the exact error message and include it in your response.

          For other requests, provide helpful, actionable responses with specific examples.
          Focus on being practical and specific to this codebase context.
          EOF

          # Run Gemini analysis with rate limiting and quota management
          echo "⏳ Running custom command analysis (rate-limited)..."
          sleep 2  # Rate limiting: 2 second delay
          RESPONSE=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/custom_command_prompt.txt)" || echo "API_ERROR: Quota exceeded")
          
          # Handle quota exceeded scenario
          if [[ "$RESPONSE" == *"API_ERROR"* ]]; then
            echo "⚠️ Gemini API quota exceeded, using fallback response..."
            RESPONSE="**⚡ API Quota Limit Reached**
            
            The Gemini 2.5 Flash model has hit the free tier limit of 250,000 tokens per minute.
            
            **Your request**: \`$COMMAND\`
            
            **What this means:**
            - You're using the correct model (gemini-2.5-flash) ✅
            - The free tier has a generous 250k token/minute limit
            - Your workflows are running frequently and hitting this limit
            
            **Solutions:**
            1. **Wait 1 minute** and try again - the quota resets every minute
            2. **Upgrade to paid tier** for higher limits
            3. **Break down large requests** into smaller ones
            4. **Use simpler commands** to reduce token usage
            
            **Next steps:** Please try your request again in 1-2 minutes, or consider upgrading your Gemini API plan for production usage.
            
            ---
            *This message confirms you're using gemini-2.5-flash correctly*"
          fi

          # Post response as comment
          cat > /tmp/response_comment.md << EOF
          ## 🤖 Gemini Response

          > **Command**: $COMMAND

          $RESPONSE

          ---
          *Generated by Gemini CLI in response to your request.*
          EOF

          # Post comment to appropriate location
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # Direct PR comment
            gh pr comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for PR #$ISSUE_NUMBER"
          else
            # Issue comment - but also comment on existing PR if one exists
            gh issue comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for issue #$ISSUE_NUMBER"
            
            # If there's an existing PR, also post the response there for visibility
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              cat > /tmp/pr_update_comment.md << EOF
          ## 🔄 Issue Update from #$ISSUE_NUMBER

          A follow-up comment was made on issue #$ISSUE_NUMBER:

          > **@gemini Command**: $COMMAND

          $RESPONSE

          ---
          *This update was automatically posted from issue #$ISSUE_NUMBER*
          EOF
              gh pr comment $EXISTING_PR_NUMBER --body-file /tmp/pr_update_comment.md
              echo "📋 Also posted update to existing PR #$EXISTING_PR_NUMBER"
            fi
          fi

      - name: Visual Testing with Browser-Use
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && 
           (contains(github.event.comment.body, 'visual') || contains(github.event.comment.body, 'screenshot') || 
            contains(github.event.comment.body, 'responsive') || contains(github.event.comment.body, 'mobile') || 
            contains(github.event.comment.body, 'tablet') || contains(github.event.comment.body, 'desktop') || 
            contains(github.event.comment.body, 'design') || contains(github.event.comment.body, 'layout') || 
            contains(github.event.comment.body, 'ui') || contains(github.event.comment.body, 'css'))) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && 
           (contains(github.event.comment.body, 'visual') || contains(github.event.comment.body, 'screenshot') || 
            contains(github.event.comment.body, 'responsive') || contains(github.event.comment.body, 'mobile') || 
            contains(github.event.comment.body, 'tablet') || contains(github.event.comment.body, 'desktop') || 
            contains(github.event.comment.body, 'design') || contains(github.event.comment.body, 'layout') || 
            contains(github.event.comment.body, 'ui') || contains(github.event.comment.body, 'css')))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "🎨 Visual testing request detected - setting up Browser-Use..."
          
          # Install Python and Browser-Use dependencies
          python -m pip install --upgrade pip
          pip install browser-use playwright opencv-python-headless numpy pillow
          playwright install chromium
          echo "✅ Browser-Use installed successfully"
          
          # Create visual test script
          cat > /tmp/visual_analysis.py << 'EOF'
          import asyncio
          import os
          import sys
          from datetime import datetime
          from pathlib import Path
          
          try:
              from browser_use import Agent
              from browser_use.browser.browser import Browser, BrowserConfig
          except ImportError:
              print("Error: browser-use not installed properly")
              sys.exit(1)
          
          async def capture_and_analyze(url, comment_text):
              """Capture screenshots and analyze visual issues"""
              
              # Default test URL if not provided
              if not url or url == "localhost":
                  url = "https://asharitech-web.pages.dev"
              
              print(f"🔍 Analyzing website: {url}")
              print(f"📝 User request: {comment_text}")
              
              # Define viewport sizes
              viewports = [
                  {"name": "Desktop", "width": 1920, "height": 1080},
                  {"name": "Tablet", "width": 768, "height": 1024},
                  {"name": "Mobile", "width": 375, "height": 667}
              ]
              
              screenshots = {}
              
              # Capture screenshots
              for viewport in viewports:
                  try:
                      config = BrowserConfig(
                          headless=True,
                          disable_security=True,
                          extra_chromium_args=['--no-sandbox', '--disable-dev-shm-usage']
                      )
                      
                      browser = Browser(config=config)
                      await browser.start()
                      
                      page = await browser.get_current_page()
                      await page.set_viewport_size({"width": viewport["width"], "height": viewport["height"]})
                      await page.goto(url, wait_until="networkidle")
                      
                      # Wait for animations
                      await asyncio.sleep(2)
                      
                      # Capture screenshot
                      filename = f"{viewport['name'].lower()}_{viewport['width']}x{viewport['height']}.png"
                      await page.screenshot(path=filename, full_page=True)
                      screenshots[viewport['name']] = filename
                      
                      print(f"✅ Captured {viewport['name']} screenshot")
                      
                      await browser.close()
                      
                  except Exception as e:
                      print(f"❌ Failed to capture {viewport['name']}: {e}")
              
              # AI Analysis using Browser-Use Agent
              agent = Agent(
                  task=f"""
                  Analyze the website at {url} based on this user request: "{comment_text}"
                  
                  Focus on:
                  1. **Responsive Design**: Check layout across desktop, tablet, and mobile
                  2. **Visual Issues**: Identify any broken layouts, overlapping elements, or spacing problems
                  3. **User Experience**: Evaluate navigation, readability, and accessibility
                  4. **Mobile Optimization**: Check touch targets, font sizes, and mobile-specific issues
                  5. **Design Consistency**: Verify brand colors, typography, and visual hierarchy
                  
                  Provide specific, actionable recommendations with CSS examples when applicable.
                  """,
                  llm=None  # Uses default model
              )
              
              try:
                  analysis_result = await agent.run()
              except Exception as e:
                  analysis_result = f"Analysis failed: {e}. However, screenshots were captured successfully."
              
              # Generate report
              report = f"""# 🎨 Visual Analysis Report
          
          **Website**: {url}
          **Timestamp**: {datetime.now().isoformat()}
          **User Request**: {comment_text}
          
          ## Screenshots Captured
          """
              
              for name, filename in screenshots.items():
                  report += f"\n### {name}\n![{name} View]({filename})\n"
              
              report += f"""
          ## AI Analysis Results
          
          {analysis_result}
          
          ## Quick Action Items
          
          Based on the analysis, here are immediate improvements:
          
          ### CSS Fixes
          ```css
          /* Responsive improvements */
          @media (max-width: 768px) {{
            .container {{
              padding: 1rem;
              max-width: 100%;
            }}
            
            .button {{
              min-height: 44px;
              min-width: 44px;
            }}
          }}
          ```
          
          ### Testing Checklist
          - [ ] Text is readable at all viewport sizes
          - [ ] Interactive elements are touch-friendly (44x44px minimum)
          - [ ] No horizontal scrolling on mobile
          - [ ] Images scale appropriately
          - [ ] Navigation works on all devices
          
          ---
          *Generated by Browser-Use Visual Testing*
          """
              
              # Save report
              with open("visual-analysis-report.md", "w") as f:
                  f.write(report)
              
              return report, screenshots
          
          async def main():
              comment = os.environ.get('COMMENT_BODY', '')
              
              # Extract URL if mentioned in comment
              url = "https://asharitech-web.pages.dev"  # Default
              if "http" in comment.lower():
                  import re
                  urls = re.findall(r'https?://[^\s]+', comment)
                  if urls:
                      url = urls[0]
              
              report, screenshots = await capture_and_analyze(url, comment)
              
              print("\n" + "="*50)
              print("Visual Analysis Complete!")
              print(f"Screenshots: {len(screenshots)}")
              print("Report saved to: visual-analysis-report.md")
              print("="*50)
              
              return report
          
          if __name__ == "__main__":
              asyncio.run(main())
          EOF
          
          # Run visual analysis
          VISUAL_REPORT=$(python /tmp/visual_analysis.py)
          
          # Upload screenshots as artifacts (if any were created)
          if ls *.png 1> /dev/null 2>&1; then
            echo "📸 Screenshots created, preparing for upload..."
            mkdir -p visual-screenshots
            mv *.png visual-screenshots/ || true
          fi
          
          # Post visual analysis results
          cat > /tmp/visual_analysis_comment.md << EOF
          ## 🎨 Visual Analysis Results
          
          $(cat visual-analysis-report.md 2>/dev/null || echo "Visual analysis completed. Check the workflow logs for details.")
          
          ---
          *Visual analysis powered by Browser-Use AI*
          EOF
          
          # Post comment with results
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            gh pr comment $ISSUE_NUMBER --body-file /tmp/visual_analysis_comment.md
            echo "✅ Visual analysis posted to PR #$ISSUE_NUMBER"
          else
            gh issue comment $ISSUE_NUMBER --body-file /tmp/visual_analysis_comment.md
            echo "✅ Visual analysis posted to issue #$ISSUE_NUMBER"
          fi

      - name: Upload Visual Test Screenshots
        if: always() && contains(github.event.comment.body, 'visual')
        uses: actions/upload-artifact@v4
        with:
          name: visual-screenshots-${{ github.run_id }}
          path: visual-screenshots/
          retention-days: 7
        continue-on-error: true

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/*.txt /tmp/*.md
          echo "🧹 Cleanup completed"

      - name: Report Status
        if: always()
        run: |
          echo "📊 Gemini CLI Automation Summary:"
          echo "- Event: ${{ github.event_name }}"
          echo "- Action: ${{ github.event.action }}"
          echo "- Issue/PR: #${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "- Status: ${{ job.status }}"