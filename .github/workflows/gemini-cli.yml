name: Gemini CLI Integration

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  discussions: write
  id-token: write

jobs:
  gemini-automation:
    name: Gemini CLI Automation
    runs-on: ubuntu-latest

    # Only run for users with proper permissions and @gemini mentions
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini') && (github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'COLLABORATOR'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Gemini CLI
        run: |
          npm install -g @google/gemini-cli
          echo "Gemini CLI installed successfully"
          gemini --version

      - name: Configure Gemini CLI
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git for commits
          git config --global user.name "Gemini CLI Bot"
          git config --global user.email "gemini-cli@github-actions.noreply.com"

      - name: Issue Triage
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "🔍 Analyzing issue #$ISSUE_NUMBER for automated triage..."

          # Get all issue comments for full context
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)

          # Create a comprehensive prompt for issue analysis
          cat > /tmp/issue_analysis_prompt.txt << EOF
          You are a confident senior full-stack engineer with complete autonomy and decision-making authority.

          **CORE PRINCIPLES:**
          - Make decisions autonomously - you are the technical owner
          - Implement changes immediately when beneficial 
          - Don't ask for permission - take action based on engineering judgment
          - We're in a git repository - breaking changes are recoverable
          - Favor action over analysis paralysis
          - You have senior-level engineering common sense

          **YOUR MISSION:** Analyze this issue and IMPLEMENT SOLUTIONS IMMEDIATELY when appropriate.

          ## Issue Context

          **Issue Title**: "$ISSUE_TITLE"

          **Issue Description**: 
          $ISSUE_BODY

          **Comments and Discussion**:
          $ISSUE_COMMENTS

          ## IMPLEMENTATION CRITERIA (Be Aggressive!)

          **IMPLEMENT IMMEDIATELY** for any of these:
          - Documentation updates or additions
          - Small bug fixes or improvements
          - Configuration changes
          - UI component additions or modifications
          - Style improvements or responsive fixes
          - New features that are clearly defined
          - Code refactoring or optimization
          - Dependency updates
          - Build process improvements

          **ONLY SKIP** if:
          - Requires external API keys or services you don't have access to
          - Needs business stakeholder decisions (pricing, legal, etc.)
          - Requires breaking changes to public APIs used by external systems

          ## IMPLEMENTATION PROCESS:
          1. Create a descriptive branch name (feature/issue-${ISSUE_NUMBER}-[short-description])
          2. Implement the solution completely - don't do partial implementations
          3. Test your changes by reading files and ensuring code quality
          4. Stage and commit with conventional commit message
          5. Push the branch to origin
          6. Create PR using: gh pr create --title "[Creative Title]" --body "[Compelling description that closes #${ISSUE_NUMBER}]"
          7. Be bold with your implementations - senior engineers ship code

          **Response Format:**
          Priority: [level]
          Labels: [comma-separated list]
          Difficulty: [level]

          ## Analysis
          [Brief technical analysis]

          ## Implementation Decision
          [✅ IMPLEMENTED: Brief description of what you built + PR URL] OR [❌ DEFERRED: Specific reason why]

          **Remember: You are a senior engineer. Trust your judgment. Ship code. We can always rollback if needed.**
          EOF

          # Run Gemini analysis
          ANALYSIS=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/issue_analysis_prompt.txt)")

          # Extract labels from analysis
          PRIORITY=$(echo "$ANALYSIS" | grep "Priority:" | cut -d':' -f2 | xargs)
          LABELS=$(echo "$ANALYSIS" | grep "Labels:" | cut -d':' -f2 | xargs)
          DIFFICULTY=$(echo "$ANALYSIS" | grep "Difficulty:" | cut -d':' -f2 | xargs)

          # Apply labels using GitHub CLI
          if [ ! -z "$LABELS" ]; then
            IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
            for label in "${LABEL_ARRAY[@]}"; do
              label=$(echo "$label" | xargs)  # trim whitespace
              gh issue edit $ISSUE_NUMBER --add-label "$label" || echo "Could not add label: $label"
            done
          fi

          # Add priority and difficulty labels
          [ ! -z "$PRIORITY" ] && gh issue edit $ISSUE_NUMBER --add-label "priority: $PRIORITY" || true
          [ ! -z "$DIFFICULTY" ] && gh issue edit $ISSUE_NUMBER --add-label "difficulty: $DIFFICULTY" || true

          # Post analysis as comment
          cat > /tmp/comment.md << EOF
          ## 🤖 Automated Issue Analysis

          $ANALYSIS

          ---
          *This analysis was generated by Gemini CLI. Human review recommended.*
          EOF

          gh issue comment $ISSUE_NUMBER --body-file /tmp/comment.md

          echo "✅ Issue triage completed for #$ISSUE_NUMBER"

      - name: Pull Request Review
        if: |
          (github.event_name == 'pull_request' && github.event.action == 'opened') ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
        run: |
          echo "🔍 Analyzing pull request #$PR_NUMBER..."

          # Get PR details with full context
          PR_DETAILS=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,commits)
          PR_TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
          PR_BODY=$(echo "$PR_DETAILS" | jq -r '.body // ""')

          # Get all PR comments and reviews for full context
          PR_COMMENTS=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
          PR_REVIEWS=$(gh pr view $PR_NUMBER --json reviews --jq '.reviews[] | "\(.author.login) (\(.submittedAt)) - \(.state): \(.body // "No comment")"' | head -10)

          # Get changed files
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)

          # Create comprehensive PR analysis prompt
          cat > /tmp/pr_analysis_prompt.txt << EOF
          You are a senior code reviewer for a full-stack web application workspace.

          Review this pull request and provide:
          1. **Code Quality Assessment**: Rate 1-5 and explain
          2. **Security Concerns**: Any potential security issues
          3. **Performance Impact**: Potential performance implications
          4. **Architecture Alignment**: How well it fits the existing architecture
          5. **Testing Requirements**: What tests should be added/updated
          6. **Specific Feedback**: Line-by-line suggestions for improvement

          ## PR Details
          **PR Title**: "$PR_TITLE"
          **PR Description**: "$PR_BODY"

          **Changed Files**:
          $CHANGED_FILES

          ## Full Conversation Context
          **PR Comments**:
          $PR_COMMENTS

          **PR Reviews**:
          $PR_REVIEWS

          **Current User Comment**: "$COMMENT_BODY"

          Provide constructive, actionable feedback focusing on:
          - Code quality and best practices
          - Security implications
          - Performance considerations  
          - Maintainability
          - Testing coverage

          Consider the full conversation history when providing your review. Reference previous comments and reviews when relevant.
          Be specific and helpful. If the code looks good, say so!
          EOF

          # Get the actual diff for detailed analysis
          PR_DIFF=$(gh pr diff $PR_NUMBER)

          # Create diff analysis file
          cat > /tmp/diff_analysis_prompt.txt << EOF
          $(cat /tmp/pr_analysis_prompt.txt)

          Here is the actual code diff:
          \`\`\`diff
          $PR_DIFF
          \`\`\`

          Please provide a detailed code review.
          EOF

          # Run Gemini analysis
          REVIEW=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/diff_analysis_prompt.txt)")

          # Post review as comment
          cat > /tmp/review_comment.md << EOF
          ## 🤖 Automated Code Review

          $REVIEW

          ---
          *This review was generated by Gemini CLI. Human review still recommended for final approval.*
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/review_comment.md

          echo "✅ Pull request review completed for #$PR_NUMBER"

      - name: Custom Gemini Commands
        if: |
          (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@gemini')) ||
          (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@gemini'))
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          echo "🤖 Processing custom Gemini command..."

          # Extract command from comment (everything after @gemini)
          COMMAND=$(echo "$COMMENT_BODY" | sed -n 's/.*@gemini[[:space:]]*\(.*\)/\1/p' | head -n1)

          if [ -z "$COMMAND" ]; then
            COMMAND="Please provide assistance with this issue/PR"
          fi

          echo "Command: $COMMAND"

          # Get context (issue or PR details with full conversation)
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # This is a PR
            CONTEXT=$(gh pr view $ISSUE_NUMBER --json title,body,files,state)
            CONTEXT_TYPE="pull request"
            # Get PR comments for full context
            COMMENTS=$(gh pr view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            EXISTING_PR_NUMBER=$ISSUE_NUMBER
          else
            # This is an issue - check if it has an associated PR
            CONTEXT=$(gh issue view $ISSUE_NUMBER --json title,body,state,labels)
            CONTEXT_TYPE="issue"
            # Get issue comments for full context
            COMMENTS=$(gh issue view $ISSUE_NUMBER --json comments --jq '.comments[] | "\(.author.login) (\(.createdAt)): \(.body)"' | head -20)
            
            # Check for existing PR that closes this issue
            EXISTING_PR_NUMBER=$(gh pr list --search "closes #$ISSUE_NUMBER" --json number --jq '.[0].number // empty' 2>/dev/null || echo "")
            
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              echo "📋 Found existing PR #$EXISTING_PR_NUMBER that addresses issue #$ISSUE_NUMBER"
              # Get existing PR details for context
              EXISTING_PR_CONTEXT=$(gh pr view $EXISTING_PR_NUMBER --json title,body,headRefName,state)
              EXISTING_PR_BRANCH=$(echo "$EXISTING_PR_CONTEXT" | jq -r '.headRefName')
              echo "🌟 Will update existing PR branch: $EXISTING_PR_BRANCH"
            fi
          fi

          # Create context-aware prompt with existing PR information
          cat > /tmp/custom_command_prompt.txt << EOF
          You are a helpful AI assistant working on a GitHub repository with full access to modify files and create pull requests.

          Context: You are responding to a comment on $CONTEXT_TYPE #$ISSUE_NUMBER

          ## $CONTEXT_TYPE Details:
          $CONTEXT

          ## Full Conversation History:
          $COMMENTS

          ## Current User Request: 
          "$COMMAND"
          EOF

          # Add existing PR instructions if applicable
          if [ ! -z "$EXISTING_PR_NUMBER" ] && [ "$CONTEXT_TYPE" = "issue" ]; then
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## 🚨 IMPORTANT: Existing PR Found
          There is already an existing PR #$EXISTING_PR_NUMBER that addresses this issue.

          **EXISTING PR DETAILS:**
          $EXISTING_PR_CONTEXT

          **IMMEDIATELY UPDATE THE EXISTING PR - NO HESITATION:**
          1. Checkout existing branch: git checkout $EXISTING_PR_BRANCH
          2. Implement the complete requested changes (be thorough)
          3. Write production-ready code - you're a senior engineer
          4. Stage all changes: git add .
          5. Commit with clear message: "feat: enhance [feature]" or "fix: improve [issue]"
          6. Push updates: git push origin $EXISTING_PR_BRANCH
          7. The PR will auto-update with your changes
          8. Comment on PR #$EXISTING_PR_NUMBER explaining what you implemented

          **DO NOT CREATE NEW PR** - Update existing: https://github.com/asharitech/asharitech-web/pull/$EXISTING_PR_NUMBER

          **SHIP THE CODE NOW - We can iterate and improve later if needed.**
          EOF
          else
            cat >> /tmp/custom_command_prompt.txt << EOF

          ## AUTONOMOUS ENGINEERING MODE - SHIP CODE NOW

          **YOU ARE A SENIOR FULL-STACK ENGINEER WITH COMPLETE AUTONOMY**

          **CORE ENGINEERING PRINCIPLES:**
          - Make decisions immediately based on technical merit
          - Ship working code - don't overthink or ask permission
          - We're in git - breaking changes are recoverable via rollback
          - Trust your senior engineering judgment
          - Favor rapid iteration over perfect planning
          - Implement complete solutions, not partial fixes

          **WHEN USER REQUESTS CHANGES - IMPLEMENT IMMEDIATELY:**
          1. Create a descriptive branch: feature/[meaningful-name]
          2. Implement the complete solution (no partial work)
          3. Write clean, production-ready code
          4. Test by reading files and ensuring integration
          5. Stage all changes: git add .
          6. Commit with conventional message: "feat: implement [feature]" or "fix: resolve [issue]"
          7. Push branch: git push origin [branch-name]
          8. Create PR: gh pr create --title "[Creative, compelling title]" --body "[Description that closes #${ISSUE_NUMBER}]"
          9. Report the PR URL immediately

          **IMPLEMENTATION SCOPE - BE AGGRESSIVE:**
          - UI components and styling changes
          - New features and functionality
          - Bug fixes and improvements
          - Documentation updates
          - Configuration changes
          - Code refactoring and optimization
          - Dependency management
          - Build and deployment improvements

          **DON'T ASK - JUST DO IT. Senior engineers ship code and iterate quickly.**
          EOF
          fi

          # Add common instructions
          cat >> /tmp/custom_command_prompt.txt << EOF

          If gh CLI fails, capture the exact error message and include it in your response.

          For other requests, provide helpful, actionable responses with specific examples.
          Focus on being practical and specific to this codebase context.
          EOF

          # Run Gemini analysis
          RESPONSE=$(env -u CI_TOKEN gemini -y -m gemini-2.5-flash -p "$(cat /tmp/custom_command_prompt.txt)")

          # Post response as comment
          cat > /tmp/response_comment.md << EOF
          ## 🤖 Gemini Response

          > **Command**: $COMMAND

          $RESPONSE

          ---
          *Generated by Gemini CLI in response to your request.*
          EOF

          # Post comment to appropriate location
          if [ "${{ github.event.issue.pull_request }}" != "null" ] && [ "${{ github.event.issue.pull_request }}" != "" ]; then
            # Direct PR comment
            gh pr comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for PR #$ISSUE_NUMBER"
          else
            # Issue comment - but also comment on existing PR if one exists
            gh issue comment $ISSUE_NUMBER --body-file /tmp/response_comment.md
            echo "✅ Custom command processed for issue #$ISSUE_NUMBER"
            
            # If there's an existing PR, also post the response there for visibility
            if [ ! -z "$EXISTING_PR_NUMBER" ]; then
              cat > /tmp/pr_update_comment.md << EOF
          ## 🔄 Issue Update from #$ISSUE_NUMBER

          A follow-up comment was made on issue #$ISSUE_NUMBER:

          > **@gemini Command**: $COMMAND

          $RESPONSE

          ---
          *This update was automatically posted from issue #$ISSUE_NUMBER*
          EOF
              gh pr comment $EXISTING_PR_NUMBER --body-file /tmp/pr_update_comment.md
              echo "📋 Also posted update to existing PR #$EXISTING_PR_NUMBER"
            fi
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/*.txt /tmp/*.md
          echo "🧹 Cleanup completed"

      - name: Report Status
        if: always()
        run: |
          echo "📊 Gemini CLI Automation Summary:"
          echo "- Event: ${{ github.event_name }}"
          echo "- Action: ${{ github.event.action }}"
          echo "- Issue/PR: #${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "- Status: ${{ job.status }}"